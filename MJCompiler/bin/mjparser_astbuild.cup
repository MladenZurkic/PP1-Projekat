package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, BREAK, CLASS, ELSE, CONST, IF, WHILE, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE;
terminal FOREACH, IDENT, PLUS, MINUS, MUL, DIV, MOD, EQ, NEQ;
terminal GT, GEQ, LT, LEQ, BITAND, BITOR, EQUAL, INC, DEC, SEMI, COMMA, DOT, LPAREN, RPAREN, LANGLE;
terminal RANGLE, LBRACE, RBRACE, LAMBDAOP;
terminal  DO, ENUM, COLON;
terminal Integer NUMBER;
terminal Character CHARCONST;
terminal Boolean BOOLCONST;

nonterminal Program Program;
nonterminal DeclsList DeclsList;
nonterminal Decls Decls;
nonterminal MethodDeclList MethodDeclList;
nonterminal ConstDecl ConstDecl;
nonterminal Consts Consts;
nonterminal ConstsList ConstsList;
nonterminal Type Type;
nonterminal VarDecl VarDecl;
nonterminal AngleBrackets AngleBrackets;
nonterminal MoreVarDecls MoreVarDecls;
nonterminal ClassDecl ClassDecl;
nonterminal ClassConstrMethodDecl ClassConstrMethodDecl;
nonterminal ExtendsOptional ExtendsOptional;
nonterminal VarDeclList VarDeclList;
nonterminal ConstMethodSecondPart ConstMethodSecondPart;
nonterminal MethodRest MethodRest;
nonterminal ConstructorDecl ConstructorDecl;
nonterminal FormParsOptional FormParsOptional;
nonterminal StatementList StatementList;
nonterminal FormPars FormPars;
nonterminal FormParsList FormParsList;
nonterminal MethodDecl MethodDecl;
nonterminal TypeOrVoid TypeOrVoid;
nonterminal Statement Statement;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ElseStatementOptional ElseStatementOptional;
nonterminal ExprOptional ExprOptional;
nonterminal NumConstOptional NumConstOptional;
nonterminal DesignatorStatementOptional DesignatorStatementOptional;
nonterminal ActParsOptional ActParsOptional;
nonterminal DesignatorOptional DesignatorOptional;
nonterminal DesignatorCommaList DesignatorCommaList;
nonterminal ActPars ActPars;
nonterminal ExprCommaList ExprCommaList;
nonterminal Condition Condition;
nonterminal CondTermList CondTermList;
nonterminal CondTerm CondTerm;
nonterminal CondFactList CondFactList;
nonterminal CondFact CondFact;
nonterminal RelOpExprOptional RelOpExprOptional;
nonterminal Expr Expr;
nonterminal MinusOptional MinusOptional;
nonterminal AddOpTermList AddOpTermList;
nonterminal Term Term;
nonterminal MulOpFactorList MulOpFactorList;
nonterminal Factor Factor;
nonterminal ActParsParen ActParsParen;
nonterminal ActParsParenOptional ActParsParenOptional;
nonterminal ExprOrActPars ExprOrActPars;
nonterminal Designator Designator;
nonterminal Label Label;
nonterminal AssignOp AssignOp;
nonterminal RelOp RelOp;
nonterminal AddOp AddOp;
nonterminal MulOp MulOp;
nonterminal ConstrMethodBothOptional ConstrMethodBothOptional;
nonterminal ConstsListElem ConstsListElem;
nonterminal VarDeclErrorPossible VarDeclErrorPossible;
nonterminal FormParsEnd FormParsEnd;
nonterminal FormParsIdent FormParsIdent;
nonterminal VarDeclListBasic VarDeclListBasic;
nonterminal VarDeclComma VarDeclComma;
nonterminal VarDeclEnd VarDeclEnd;
nonterminal VarDeclIdent VarDeclIdent;

precedence left ELSE;

Program ::= (Program) PROG IDENT:progName DeclsList:D1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(D1, M2); RESULT.setLine(D1left); :};

DeclsList ::= (Declarations) DeclsList:D1 Decls:D2 {: RESULT=new Declarations(D1, D2); RESULT.setLine(D1left); :}
			| 
			(NoVarDecl) {: RESULT=new NoVarDecl(); :} /* epsilon */
			;

Decls ::= (DeclsConstDecl) ConstDecl:C1 {: RESULT=new DeclsConstDecl(C1); RESULT.setLine(C1left); :}
		| (DeclsVarDecl) VarDeclErrorPossible:V1 {: RESULT=new DeclsVarDecl(V1); RESULT.setLine(V1left); :}
		| (DeclsClassDecl) ClassDecl:C1 {: RESULT=new DeclsClassDecl(C1); RESULT.setLine(C1left); :};


MethodDeclList ::= MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclListDerived1(M1, M2); RESULT.setLine(M1left); :}  
				| (NoMethodDeclList) {: RESULT=new NoMethodDeclList(); :} /* epsilon */
				;

ConstDecl ::= (ConstDeclDef) CONST Type:type ConstsList:C1 SEMI {: RESULT=new ConstDeclDef(type, C1); RESULT.setLine(typeleft); :};
			

Consts ::= (ConstsNumber) NUMBER:N1 {: RESULT=new ConstsNumber(N1); RESULT.setLine(N1left); :}
		| (ConstsCharConst) CHARCONST:C1 {: RESULT=new ConstsCharConst(C1); RESULT.setLine(C1left); :}
		| (ConstsBoolConst) BOOLCONST:B1 {: RESULT=new ConstsBoolConst(B1); RESULT.setLine(B1left); :};
		
ConstsList ::= (ConstsListDef) ConstsList:C1 COMMA ConstsListElem:C2 {: RESULT=new ConstsListDef(C1, C2); RESULT.setLine(C1left); :}
			| (ConstsListElemInList) ConstsListElem:C1 {: RESULT=new ConstsListElemInList(C1); RESULT.setLine(C1left); :}
			;
			
ConstsListElem ::= (ConstsListElem) IDENT:id EQUAL Consts:value {: RESULT=new ConstsListElem(value); RESULT.setLine(valueleft); :};

Type ::= (Type) IDENT:typeName {: RESULT=new Type(); :};

VarDecl ::= (DefVarDecl) Type:typeName VarDeclIdent:V1 MoreVarDecls:M2 SEMI {: RESULT=new DefVarDecl(typeName, V1, M2); RESULT.setLine(typeNameleft); :};

VarDeclErrorPossible ::= (VarDeclErrorPossible) Type:typeName VarDeclListBasic:V1 {: RESULT=new VarDeclErrorPossible(typeName, V1); RESULT.setLine(typeNameleft); :};

VarDeclListBasic ::= (VarDeclListBasicDef) VarDeclComma:V1 VarDeclListBasic:V2 {: RESULT=new VarDeclListBasicDef(V1, V2); RESULT.setLine(V1left); :}
				| (VarDeclListBasicEnd) VarDeclEnd:V1 {: RESULT=new VarDeclListBasicEnd(V1); RESULT.setLine(V1left); :};


VarDeclComma ::= (VarDeclCommaDef) VarDeclIdent:V1 COMMA {: RESULT=new VarDeclCommaDef(V1); RESULT.setLine(V1left); :}
				| (ErrorVarDeclListBasic) error:err COMMA
				{: parser.report_error("Izvrsen oporavak do , (VarDeclComma) u liniji " + errleft, null);  :} {: RESULT=new ErrorVarDeclListBasic(); :}
				;

VarDeclEnd ::= (VarDeclEndDef) VarDeclIdent:V1 SEMI {: RESULT=new VarDeclEndDef(V1); RESULT.setLine(V1left); :}
			| (ErrorVarDecl) error:err SEMI
			{: parser.report_error("Izvrsen oporavak do ; (VarDeclEnd) u liniji " + errleft, null);  :} {: RESULT=new ErrorVarDecl(); :}
			;

VarDeclIdent ::= (VarDeclIdent) IDENT:ident AngleBrackets:A1 {: RESULT=new VarDeclIdent(A1); RESULT.setLine(A1left); :};


AngleBrackets ::= (AngleBrackets) LANGLE RANGLE {: RESULT=new AngleBrackets(); :}
				| (NoAngleBrackets) {: RESULT=new NoAngleBrackets(); :} /* epsilon */
				;

MoreVarDecls ::= (MoreVarDeclsDef) MoreVarDecls:M1 COMMA VarDeclIdent:V2 {: RESULT=new MoreVarDeclsDef(M1, V2); RESULT.setLine(M1left); :}
			| (MoreVarDeclsEpislon) {: RESULT=new MoreVarDeclsEpislon(); :} /* epsilon */
			;
			
ClassDecl ::= (ClassDecl) CLASS IDENT:ident ExtendsOptional:E1 LBRACE VarDeclList:V2 ClassConstrMethodDecl:C3 RBRACE {: RESULT=new ClassDecl(E1, V2, C3); RESULT.setLine(E1left); :};

ExtendsOptional ::= (ExtendsOptionalDef) EXTENDS Type:typeName {: RESULT=new ExtendsOptionalDef(typeName); RESULT.setLine(typeNameleft); :}
			| (ExtendsOptionalEpsilon) {: RESULT=new ExtendsOptionalEpsilon(); :} /* epsilon */
			;

VarDeclList ::= (VarDeclsList) VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclsList(V1, V2); RESULT.setLine(V1left); :}
			| (VarDeclsListEpsilon) {: RESULT=new VarDeclsListEpsilon(); :} /* epsilon */
			;
			
ClassConstrMethodDecl ::= (ClassConstrMethodDeclDef) LBRACE ConstrMethodBothOptional:C1 RBRACE {: RESULT=new ClassConstrMethodDeclDef(C1); RESULT.setLine(C1left); :}
						| (ClassConstrMethodDeclEpsilon) {: RESULT=new ClassConstrMethodDeclEpsilon(); :} /* epsilon */
						;

ConstrMethodBothOptional ::= (ConstrMethodBothConstrPart) IDENT:ident ConstMethodSecondPart:C1 ConstrMethodBothOptional:C2 {: RESULT=new ConstrMethodBothConstrPart(C1, C2); RESULT.setLine(C1left); :}
							| (ConstrMethodBothMethodIdentPart) IDENT:typeName IDENT:ident ConstMethodSecondPart:C1 MethodRest:M2 {: RESULT=new ConstrMethodBothMethodIdentPart(C1, M2); RESULT.setLine(C1left); :}
							| (ConstrMethodBothMethodVoidPart) VOID:typeName IDENT:ident ConstMethodSecondPart:C1 MethodRest:M2 {: RESULT=new ConstrMethodBothMethodVoidPart(C1, M2); RESULT.setLine(C1left); :}
							| (ConstrMethodBothMethodEpsilon) {: RESULT=new ConstrMethodBothMethodEpsilon(); :} /* epsilon */
							;

ConstMethodSecondPart ::= (ConstMethodSecondPart) LPAREN FormParsOptional:F1 VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new ConstMethodSecondPart(F1, V2, S3); RESULT.setLine(F1left); :};

MethodRest ::= (MethodRestIdent) IDENT:typeName IDENT:ident ConstMethodSecondPart:C1 MethodRest:M2 {: RESULT=new MethodRestIdent(C1, M2); RESULT.setLine(C1left); :}
			| (MethodRestVoid) VOID:typeName IDENT:ident ConstMethodSecondPart:C1 MethodRest:M2 {: RESULT=new MethodRestVoid(C1, M2); RESULT.setLine(C1left); :}
			| (MethodRestEpsilon) {: RESULT=new MethodRestEpsilon(); :} /* epsilon */
			;

ConstructorDecl ::= (ConstructorDecl) IDENT:ident LPAREN FormParsOptional:F1 VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new ConstructorDecl(F1, V2, S3); RESULT.setLine(F1left); :};

FormParsOptional ::= (FormParsOptionalPars) FormPars:F1 {: RESULT=new FormParsOptionalPars(F1); RESULT.setLine(F1left); :}
					| (FormParsOptionalRPAREN) RPAREN {: RESULT=new FormParsOptionalRPAREN(); :}
					;
					
StatementList ::= (StatementListDef) StatementList:S1 Statement:S2 {: RESULT=new StatementListDef(S1, S2); RESULT.setLine(S1left); :}
				| (StatementListEpsilon) {: RESULT=new StatementListEpsilon(); :} /* epsilon */
				;

FormPars ::= (FormParsWithList) FormParsList:F1 FormPars:F2 {: RESULT=new FormParsWithList(F1, F2); RESULT.setLine(F1left); :}
			| (FormParsListEnd) FormParsEnd:F1 {: RESULT=new FormParsListEnd(F1); RESULT.setLine(F1left); :}
			;

FormParsList ::= (FormParsListWithCOMMA) FormParsIdent:F1 COMMA {: RESULT=new FormParsListWithCOMMA(F1); RESULT.setLine(F1left); :}
				| (ErrorFormParsListCOMMA) error:err COMMA
				{: parser.report_error("Izvrsen oporavak do , (FormParsList) u liniji " + errleft, null);  :} {: RESULT=new ErrorFormParsListCOMMA(); :}
				;
				
FormParsEnd ::= (FormParsEndWithRPAREN) FormParsIdent:F1 RPAREN {: RESULT=new FormParsEndWithRPAREN(F1); RESULT.setLine(F1left); :}
			| (ErrorFormParsEndRPAREN) error:err RPAREN
			{: parser.report_error("Izvrsen oporavak do ) (FormParsEnd) u liniji " + errleft, null);  :} {: RESULT=new ErrorFormParsEndRPAREN(); :}
			;
			
FormParsIdent ::= (FormParsIdent) Type:typeName IDENT:formName AngleBrackets:A1 {: RESULT=new FormParsIdent(typeName, A1); RESULT.setLine(typeNameleft); :};
				
MethodDecl ::= (MethodDecl) TypeOrVoid:typeName IDENT:methName LPAREN FormParsOptional:F1 VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new MethodDecl(typeName, F1, V2, S3); RESULT.setLine(typeNameleft); :};

TypeOrVoid ::= (TypeOrVoidType) Type:typeName {: RESULT=new TypeOrVoidType(typeName); RESULT.setLine(typeNameleft); :}
			| (TypeOrVoidVoid) VOID:typeName {: RESULT=new TypeOrVoidVoid(); :};

Statement ::= (DesignatorStmt) DesignatorStatement:designatorStmt {: RESULT=new DesignatorStmt(designatorStmt); RESULT.setLine(designatorStmtleft); :}
			| (IfStmt) IF LPAREN Condition:condition RPAREN Statement:stmt ElseStatementOptional:E1 {: RESULT=new IfStmt(condition, stmt, E1); RESULT.setLine(conditionleft); :}
			| (WhileStmt) WHILE LPAREN Condition:condition RPAREN Statement:stmt {: RESULT=new WhileStmt(condition, stmt); RESULT.setLine(conditionleft); :}
			| (BreakStmt) BREAK SEMI {: RESULT=new BreakStmt(); :}
			| (ContinueStmt) CONTINUE SEMI {: RESULT=new ContinueStmt(); :}
			| (ReturnStmt) RETURN ExprOptional:ExprOpt SEMI {: RESULT=new ReturnStmt(ExprOpt); RESULT.setLine(ExprOptleft); :}
			| (ReadStmt) READ LPAREN Designator:designator RPAREN SEMI {: RESULT=new ReadStmt(designator); RESULT.setLine(designatorleft); :}
			| (PrintStmt) PRINT LPAREN Expr:expr NumConstOptional:numOpt RPAREN SEMI {: RESULT=new PrintStmt(expr, numOpt); RESULT.setLine(exprleft); :}
			| (ForEachStmt) Designator:designator DOT FOREACH LPAREN IDENT:ident LAMBDAOP Statement:stmt RPAREN SEMI {: RESULT=new ForEachStmt(designator, stmt); RESULT.setLine(designatorleft); :}
			| (StmtList) LBRACE StatementList:S1 RBRACE {: RESULT=new StmtList(S1); RESULT.setLine(S1left); :}
			| (ErrorStmtIFCondition) IF LPAREN error:err RPAREN
			{: parser.report_error("Izvrsen oporavak do ) (IF condition) u liniji " + errleft, null);  :} {: RESULT=new ErrorStmtIFCondition(); :}
			;

DesignatorStatement ::= (DesignatorStmtDef) Designator:D1 DesignatorStatementOptional:D2 SEMI {: RESULT=new DesignatorStmtDef(D1, D2); RESULT.setLine(D1left); :}
					| (DesignatorStmtAngleBrack) LANGLE DesignatorOptional:D1 DesignatorCommaList:D2 RANGLE EQUAL Designator:D3 SEMI {: RESULT=new DesignatorStmtAngleBrack(D1, D2, D3); RESULT.setLine(D1left); :}
					| (ErrorDesignatorStmtSEMI) error:err SEMI
					{: parser.report_error("Izvrsen oporavak do ; (DesignatorStmt) u liniji " + errleft, null);  :} {: RESULT=new ErrorDesignatorStmtSEMI(); :}
					;

ElseStatementOptional ::= (ElseStmtOpt) ELSE Statement:stmt {: RESULT=new ElseStmtOpt(stmt); RESULT.setLine(stmtleft); :}
						| (ElseStmtEpsilon) {: RESULT=new ElseStmtEpsilon(); :} /* epsilon */
						;

ExprOptional ::= (ExprOpt) Expr:expr {: RESULT=new ExprOpt(expr); RESULT.setLine(exprleft); :}
				| (ExprEpsilon) {: RESULT=new ExprEpsilon(); :} /* epsilon */
				;

NumConstOptional ::= (NumConstOpt) COMMA NUMBER:N1 {: RESULT=new NumConstOpt(N1); RESULT.setLine(N1left); :}
				| (NumConstEpsilon) {: RESULT=new NumConstEpsilon(); :} /* epsilon */
				;




DesignatorStatementOptional ::= (DesignatorStmtOptAssign) AssignOp:A1 Expr:expr {: RESULT=new DesignatorStmtOptAssign(A1, expr); RESULT.setLine(A1left); :}
							| (DesignatorStmtOptActPars) LPAREN ActParsOptional:A1 RPAREN {: RESULT=new DesignatorStmtOptActPars(A1); RESULT.setLine(A1left); :}
							| (DesignatorStmtOptINC) INC {: RESULT=new DesignatorStmtOptINC(); :}
							| (DesignatorStmtOptDEC) DEC {: RESULT=new DesignatorStmtOptDEC(); :};
							
ActParsOptional ::= (ActParsOpt) ActPars:A1 {: RESULT=new ActParsOpt(A1); RESULT.setLine(A1left); :}
				| (ActParsOptEpsilon) {: RESULT=new ActParsOptEpsilon(); :} /* epsilon */
				;

DesignatorOptional ::= (DesignatorOpt) Designator:D1 {: RESULT=new DesignatorOpt(D1); RESULT.setLine(D1left); :}
					| (DesignatorOptEpsilon) {: RESULT=new DesignatorOptEpsilon(); :} /* epsilon */
					;

DesignatorCommaList ::= (DesignatorCommaListDef) DesignatorCommaList:D1 COMMA DesignatorOptional:D2 {: RESULT=new DesignatorCommaListDef(D1, D2); RESULT.setLine(D1left); :}
					| (DesignatorCommaListEpsilon) {: RESULT=new DesignatorCommaListEpsilon(); :} /* epsilon */
					;



ActPars ::= (ActPars) Expr:expr ExprCommaList:E1 {: RESULT=new ActPars(expr, E1); RESULT.setLine(exprleft); :};

ExprCommaList ::= (ExprCommaListDef) ExprCommaList:E1 COMMA Expr:expr {: RESULT=new ExprCommaListDef(E1, expr); RESULT.setLine(E1left); :}
				| (ExprCommaListEpsilon) {: RESULT=new ExprCommaListEpsilon(); :} /* epsilon */
				;

Condition ::= (Condition) CondTerm:C1 CondTermList:C2 {: RESULT=new Condition(C1, C2); RESULT.setLine(C1left); :};

CondTermList ::= (CondTermListDef) CondTermList:C1 BITOR CondTerm:C2 {: RESULT=new CondTermListDef(C1, C2); RESULT.setLine(C1left); :}
				| (CondTermListEpsilon) {: RESULT=new CondTermListEpsilon(); :} /* epsilon */
				;

CondTerm ::= (CondTerm) CondFact:C1 CondFactList:C2 {: RESULT=new CondTerm(C1, C2); RESULT.setLine(C1left); :};

CondFactList ::= (CondFactListDef) CondFactList:C1 BITAND CondFact:C2 {: RESULT=new CondFactListDef(C1, C2); RESULT.setLine(C1left); :}
				| (CondFactListEpsilon) {: RESULT=new CondFactListEpsilon(); :} /* epsilon */
				;
				
CondFact ::= (CondFact) Expr:E1 RelOpExprOptional:R2 {: RESULT=new CondFact(E1, R2); RESULT.setLine(E1left); :};

RelOpExprOptional ::= (RelOpExprDef) RelOp:R1 Expr:E2 {: RESULT=new RelOpExprDef(R1, E2); RESULT.setLine(R1left); :}
					| (RelOpExprEpsilon) {: RESULT=new RelOpExprEpsilon(); :} /* epsilon */
					;



Expr ::= (Expr) MinusOptional:M1 Term:term AddOpTermList:A2 {: RESULT=new Expr(M1, term, A2); RESULT.setLine(M1left); :};

MinusOptional ::= (MinusDef) MINUS {: RESULT=new MinusDef(); :}
			| (MinusEpsilon) {: RESULT=new MinusEpsilon(); :} /* epsilon */
			;

AddOpTermList ::= (AddOpTermListDef) AddOpTermList:A1 AddOp:A2 Term:term {: RESULT=new AddOpTermListDef(A1, A2, term); RESULT.setLine(A1left); :}
				| (AddOpTermListEpsilon) {: RESULT=new AddOpTermListEpsilon(); :} /* epsilon */
				;



Term ::= (Term) Factor:factor MulOpFactorList:M1 {: RESULT=new Term(factor, M1); RESULT.setLine(factorleft); :};

MulOpFactorList ::= (MulOpFactorListDef) MulOpFactorList:M1 MulOp:M2 Factor:F3 {: RESULT=new MulOpFactorListDef(M1, M2, F3); RESULT.setLine(M1left); :}
				| (MulOpFactorListEpsilon) {: RESULT=new MulOpFactorListEpsilon(); :} /* epsilon */
				;



Factor ::= (FactorDesignator) Designator:designator ActParsParenOptional:A1 {: RESULT=new FactorDesignator(designator, A1); RESULT.setLine(designatorleft); :}
		| (FactorNumber) NUMBER:N1 {: RESULT=new FactorNumber(N1); RESULT.setLine(N1left); :}
		| (FactorChar) CHARCONST:C1 {: RESULT=new FactorChar(C1); RESULT.setLine(C1left); :}
		| (FactorBool) BOOLCONST:B1 {: RESULT=new FactorBool(B1); RESULT.setLine(B1left); :}
		| (FactorNew) NEW Type:typeName ExprOrActPars:E1 {: RESULT=new FactorNew(typeName, E1); RESULT.setLine(typeNameleft); :}
		| (FactorExpr) LPAREN Expr:expr RPAREN {: RESULT=new FactorExpr(expr); RESULT.setLine(exprleft); :};




ActParsParen ::= (ActParsParen) LPAREN ActParsOptional:A1 RPAREN {: RESULT=new ActParsParen(A1); RESULT.setLine(A1left); :};

ActParsParenOptional ::= (ActParsParenDef) ActParsParen:A1 {: RESULT=new ActParsParenDef(A1); RESULT.setLine(A1left); :}
						| (ActParsParenEpsilon) {: RESULT=new ActParsParenEpsilon(); :} /* epsilon */
						;

ExprOrActPars ::= (ExprOrActParsExpr) LANGLE Expr:expr RANGLE {: RESULT=new ExprOrActParsExpr(expr); RESULT.setLine(exprleft); :}
				| (ExprOrActParsActPars) LPAREN ActParsOptional:A1 RPAREN {: RESULT=new ExprOrActParsActPars(A1); RESULT.setLine(A1left); :};



Designator ::= (DesignatorIdent) IDENT:ident {: RESULT=new DesignatorIdent(); :}
			| (DesignatorDotIdent) Designator:designator DOT IDENT:ident {: RESULT=new DesignatorDotIdent(designator); RESULT.setLine(designatorleft); :}
			| (DesignatorExpr) Designator:designator LANGLE Expr:E1 RANGLE {: RESULT=new DesignatorExpr(designator, E1); RESULT.setLine(designatorleft); :}
			;

Label ::= (Label) IDENT:ident {: RESULT=new Label(); :};
AssignOp ::= (AssignOp) EQUAL {: RESULT=new AssignOp(); :};
RelOp ::= (RelEQ) EQ {: RESULT=new RelEQ(); :} | (RelNEQ) NEQ {: RESULT=new RelNEQ(); :} | (RelGT) GT {: RESULT=new RelGT(); :} | (RelGEQ) GEQ {: RESULT=new RelGEQ(); :} | (RelLT) LT {: RESULT=new RelLT(); :} | (RelLEQ) LEQ {: RESULT=new RelLEQ(); :};
AddOp ::= (AddPLUS) PLUS {: RESULT=new AddPLUS(); :} | (AddMINUS) MINUS {: RESULT=new AddMINUS(); :};
MulOp ::= (MulMUL) MUL {: RESULT=new MulMUL(); :} | (MulDIV) DIV {: RESULT=new MulDIV(); :} | (MulMOD) MOD {: RESULT=new MulMOD(); :};


