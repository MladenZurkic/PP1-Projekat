package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, BREAK, CLASS, ELSE, CONST, IF, WHILE, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE;
terminal FOREACH, IDENT, PLUS, MINUS, MUL, DIV, MOD, EQ, NEQ, RANGLE, LBRACE, RBRACE, LAMBDAOP;
terminal GT, GEQ, LT, LEQ, BITAND, BITOR, EQUAL, INC, DEC, SEMI, COMMA, DOT, LPAREN, RPAREN, LANGLE;
terminal COLON, DO, ENUM;
terminal Integer NUMBER;
terminal Character CHARCONST;
terminal Boolean BOOLCONST;

nonterminal DeclsList DeclsList;
nonterminal Decls Decls;
nonterminal MethodDeclList MethodDeclList;
nonterminal ConstDecl ConstDecl;
nonterminal Consts Consts;
nonterminal ConstsList ConstsList;
nonterminal Type Type;
nonterminal VarDecl VarDecl;
nonterminal AngleBrackets AngleBrackets;
nonterminal MoreVarDecls MoreVarDecls;
nonterminal ClassDecl ClassDecl;
nonterminal ClassConstrMethodDecl ClassConstrMethodDecl;
nonterminal ConstructorDecl ConstructorDecl;
nonterminal FormParsOptional FormParsOptional;
nonterminal StatementList StatementList;
nonterminal FormPars FormPars;
nonterminal FormParsList FormParsList;
nonterminal MethodDecl MethodDecl;
nonterminal TypeOrVoid TypeOrVoid;
nonterminal Statement Statement;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ElseStatementOptional ElseStatementOptional;
nonterminal ExprOptional ExprOptional;
nonterminal NumConstOptional NumConstOptional;
nonterminal DesignatorStatementOptional DesignatorStatementOptional;
nonterminal ActParsOptional ActParsOptional;
nonterminal DesignatorOptional DesignatorOptional;
nonterminal DesignatorCommaList DesignatorCommaList;
nonterminal ActPars ActPars;
nonterminal ExprCommaList ExprCommaList;
nonterminal Condition Condition;
nonterminal CondTermList CondTermList;
nonterminal CondTerm CondTerm;
nonterminal CondFactList CondFactList;
nonterminal CondFact CondFact;
nonterminal RelOpExprOptional RelOpExprOptional;
nonterminal Expr Expr;
nonterminal MinusOptional MinusOptional;
nonterminal AddOpTermList AddOpTermList;
nonterminal Term Term;
nonterminal MulOpFactorList MulOpFactorList;
nonterminal Factor Factor;
nonterminal ActParsParen ActParsParen;
nonterminal ActParsParenOptional ActParsParenOptional;
nonterminal ExprOrActPars ExprOrActPars;
nonterminal Designator Designator;
nonterminal Label Label;
nonterminal AssignOp AssignOp;
nonterminal RelOp RelOp;
nonterminal AddOp AddOp;
nonterminal MulOp MulOp;
nonterminal ConstsListElem ConstsListElem;
nonterminal GlobalVarDecl GlobalVarDecl;
nonterminal FormParsEnd FormParsEnd;
nonterminal FormParsIdent FormParsIdent;
nonterminal ExtendsOptional ExtendsOptional;
nonterminal VarDeclList VarDeclList;
nonterminal GlobalVarDeclList GlobalVarDeclList;
nonterminal VarDeclComma VarDeclComma;
nonterminal VarDeclEnd VarDeclEnd;
nonterminal VarDeclIdent VarDeclIdent;
nonterminal ConstructorDeclList ConstructorDeclList;
nonterminal ClassMethodDeclList ClassMethodDeclList;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program;


precedence left ELSE;

Program ::= (Program) PROG ProgName:p DeclsList:D1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(p, D1, M2); RESULT.setLine(pleft); :};

ProgName ::= (ProgName) IDENT:prognm {: RESULT=new ProgName(); :};

DeclsList ::= (Declarations) DeclsList:D1 Decls:D2 {: RESULT=new Declarations(D1, D2); RESULT.setLine(D1left); :}
			| 
			(NoDeclarations) {: RESULT=new NoDeclarations(); :} /* epsilon */
			;

Decls ::= (DeclsConstDecl) ConstDecl:C1 {: RESULT=new DeclsConstDecl(C1); RESULT.setLine(C1left); :}
		| (DeclsVarDecl) GlobalVarDecl:G1 {: RESULT=new DeclsVarDecl(G1); RESULT.setLine(G1left); :}
		| (DeclsClassDecl) ClassDecl:C1 {: RESULT=new DeclsClassDecl(C1); RESULT.setLine(C1left); :};


MethodDeclList ::= (MethodDeclLists) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclLists(M1, M2); RESULT.setLine(M1left); :}  
				| (NoMethodDeclList) {: RESULT=new NoMethodDeclList(); :} /* epsilon */
				;

ConstDecl ::= (ConstDecl) CONST Type:type ConstsList:C1 SEMI {: RESULT=new ConstDecl(type, C1); RESULT.setLine(typeleft); :};
			

Consts ::= (NumberConst) NUMBER:N1 {: RESULT=new NumberConst(N1); RESULT.setLine(N1left); :}
		| (CharConst) CHARCONST:C1 {: RESULT=new CharConst(C1); RESULT.setLine(C1left); :}
		| (BoolConst) BOOLCONST:B1 {: RESULT=new BoolConst(B1); RESULT.setLine(B1left); :};
		
ConstsList ::= (ConstsLists) ConstsList:C1 COMMA ConstsListElem:C2 {: RESULT=new ConstsLists(C1, C2); RESULT.setLine(C1left); :}
			| (ConstsListSingle) ConstsListElem:C1 {: RESULT=new ConstsListSingle(C1); RESULT.setLine(C1left); :}
			;
			
ConstsListElem ::= (ConstsListElem) IDENT:id EQUAL Consts:value {: RESULT=new ConstsListElem(value); RESULT.setLine(valueleft); :};

Type ::= (Type) IDENT:typeName {: RESULT=new Type(); :};

VarDecl ::= (VarDecl) Type:typeName VarDeclIdent:V1 MoreVarDecls:M2 SEMI {: RESULT=new VarDecl(typeName, V1, M2); RESULT.setLine(typeNameleft); :};

GlobalVarDecl ::= (GlobalVarDecl) Type:typeName GlobalVarDeclList:G1 {: RESULT=new GlobalVarDecl(typeName, G1); RESULT.setLine(typeNameleft); :};

GlobalVarDeclList ::= (GlobalVarDeclLists) VarDeclComma:V1 GlobalVarDeclList:G2 {: RESULT=new GlobalVarDeclLists(V1, G2); RESULT.setLine(V1left); :}
				| (GlobalVarDeclListEnd) VarDeclEnd:V1 {: RESULT=new GlobalVarDeclListEnd(V1); RESULT.setLine(V1left); :};


VarDeclComma ::= (VarDeclCommaDef) VarDeclIdent:V1 COMMA {: RESULT=new VarDeclCommaDef(V1); RESULT.setLine(V1left); :}
				| (ErrorVarDeclComma) error:err COMMA
				{: parser.report_error("Izvrsen oporavak do , (VarDeclComma) u liniji " + errleft, null);  :} {: RESULT=new ErrorVarDeclComma(); :}
				;

VarDeclEnd ::= (VarDeclEndDef) VarDeclIdent:V1 SEMI {: RESULT=new VarDeclEndDef(V1); RESULT.setLine(V1left); :}
			| (ErrorVarDeclEnd) error:err SEMI
			{: parser.report_error("Izvrsen oporavak do ; (VarDeclEnd) u liniji " + errleft, null);  :} {: RESULT=new ErrorVarDeclEnd(); :}
			;

VarDeclIdent ::= (VarDeclIdent) IDENT:ident AngleBrackets:A1 {: RESULT=new VarDeclIdent(A1); RESULT.setLine(A1left); :};


AngleBrackets ::= (AngleBrackets) LANGLE RANGLE {: RESULT=new AngleBrackets(); :}
				| (NoAngleBrackets) {: RESULT=new NoAngleBrackets(); :} /* epsilon */
				;

MoreVarDecls ::= (MoreVarDeclsDef) MoreVarDecls:M1 COMMA VarDeclIdent:V2 {: RESULT=new MoreVarDeclsDef(M1, V2); RESULT.setLine(M1left); :}
			| (NoMoreVarDecls) {: RESULT=new NoMoreVarDecls(); :} /* epsilon */
			;
			
ClassDecl ::= (ClassDecl) CLASS IDENT:ident ExtendsOptional:E1 LBRACE VarDeclList:V2 ClassConstrMethodDecl:C3 RBRACE {: RESULT=new ClassDecl(E1, V2, C3); RESULT.setLine(E1left); :};

ExtendsOptional ::= (ExtendsOptionalDef) EXTENDS Type:typeName {: RESULT=new ExtendsOptionalDef(typeName); RESULT.setLine(typeNameleft); :}
			| (NoExtendsOptional) {: RESULT=new NoExtendsOptional(); :} /* epsilon */
			;

VarDeclList ::= (VarDeclLists) VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclLists(V1, V2); RESULT.setLine(V1left); :}
			| (NoVarDeclList) {: RESULT=new NoVarDeclList(); :} /* epsilon */
			;



ClassConstrMethodDecl ::= (ClassConstrMethodDeclOnlyBraces) LBRACE RBRACE {: RESULT=new ClassConstrMethodDeclOnlyBraces(); :}
						| (ClassConstrMethodDeclOnlyConstructor) LBRACE ConstructorDeclList:C1 RBRACE {: RESULT=new ClassConstrMethodDeclOnlyConstructor(C1); RESULT.setLine(C1left); :}
						| (ClassConstrMethodDecOnlyMethod) LBRACE ClassMethodDeclList:C1 RBRACE {: RESULT=new ClassConstrMethodDecOnlyMethod(C1); RESULT.setLine(C1left); :}
						| (ClassConstrMethodDeclBoth) LBRACE ConstructorDeclList:C1 ClassMethodDeclList:C2 RBRACE {: RESULT=new ClassConstrMethodDeclBoth(C1, C2); RESULT.setLine(C1left); :}
						| (NoClassConstrMethodDecl) {: RESULT=new NoClassConstrMethodDecl(); :} /*epsilon*/
						;

ConstructorDeclList ::= (ConstructorDeclLists) ConstructorDeclList:C1 ConstructorDecl:C2 {: RESULT=new ConstructorDeclLists(C1, C2); RESULT.setLine(C1left); :}
					| (ConstructorDeclListSingle) ConstructorDecl:C1 {: RESULT=new ConstructorDeclListSingle(C1); RESULT.setLine(C1left); :};

ClassMethodDeclList ::= (ClassMethodDeclListDef) ClassMethodDeclList:C1 MethodDecl:M2 {: RESULT=new ClassMethodDeclListDef(C1, M2); RESULT.setLine(C1left); :} 
					| (ClassMethodDeclListSingle) MethodDecl:M1 {: RESULT=new ClassMethodDeclListSingle(M1); RESULT.setLine(M1left); :};


ConstructorDecl ::= (ConstructorDecl) IDENT:constName LPAREN FormParsOptional:F1 VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new ConstructorDecl(F1, V2, S3); RESULT.setLine(F1left); :};
MethodDecl ::= (MethodDecl) TypeOrVoid:typeName IDENT:methName LPAREN FormParsOptional:F1 VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new MethodDecl(typeName, F1, V2, S3); RESULT.setLine(typeNameleft); :};


FormParsOptional ::= (FormParsOptionalPars) FormPars:F1 {: RESULT=new FormParsOptionalPars(F1); RESULT.setLine(F1left); :}
					| (FormParsOptionalRPAREN) RPAREN {: RESULT=new FormParsOptionalRPAREN(); :}
					;
					
StatementList ::= (StatementListDef) StatementList:S1 Statement:S2 {: RESULT=new StatementListDef(S1, S2); RESULT.setLine(S1left); :}
				| (NoStatementList) {: RESULT=new NoStatementList(); :} /* epsilon */
				;

FormPars ::= (FormParsWithList) FormParsList:F1 FormPars:F2 {: RESULT=new FormParsWithList(F1, F2); RESULT.setLine(F1left); :}
			| (FormParsListEnd) FormParsEnd:F1 {: RESULT=new FormParsListEnd(F1); RESULT.setLine(F1left); :}
			;

FormParsList ::= (FormParsListWithCOMMA) FormParsIdent:F1 COMMA {: RESULT=new FormParsListWithCOMMA(F1); RESULT.setLine(F1left); :}
				| (ErrorFormParsListCOMMA) error:err COMMA
				{: parser.report_error("Izvrsen oporavak do , (FormParsList) u liniji " + errleft, null);  :} {: RESULT=new ErrorFormParsListCOMMA(); :}
				;
				
FormParsEnd ::= (FormParsEndWithRPAREN) FormParsIdent:F1 RPAREN {: RESULT=new FormParsEndWithRPAREN(F1); RESULT.setLine(F1left); :}
			| (ErrorFormParsEndRPAREN) error:err RPAREN
			{: parser.report_error("Izvrsen oporavak do ) (FormParsEnd) u liniji " + errleft, null);  :} {: RESULT=new ErrorFormParsEndRPAREN(); :}
			;
			
FormParsIdent ::= (FormParsIdent) Type:typeName IDENT:formName AngleBrackets:A1 {: RESULT=new FormParsIdent(typeName, A1); RESULT.setLine(typeNameleft); :};
				
TypeOrVoid ::= (TypeOrVoidType) Type:typeName {: RESULT=new TypeOrVoidType(typeName); RESULT.setLine(typeNameleft); :}
			| (TypeOrVoidVoid) VOID:typeName {: RESULT=new TypeOrVoidVoid(); :};

Statement ::= (DesignatorStmt) DesignatorStatement:designatorStmt {: RESULT=new DesignatorStmt(designatorStmt); RESULT.setLine(designatorStmtleft); :}
			| (IfStmt) IF LPAREN Condition:condition RPAREN Statement:stmt ElseStatementOptional:E1 {: RESULT=new IfStmt(condition, stmt, E1); RESULT.setLine(conditionleft); :}
			| (WhileStmt) WHILE LPAREN Condition:condition RPAREN Statement:stmt {: RESULT=new WhileStmt(condition, stmt); RESULT.setLine(conditionleft); :}
			| (BreakStmt) BREAK SEMI {: RESULT=new BreakStmt(); :}
			| (ContinueStmt) CONTINUE SEMI {: RESULT=new ContinueStmt(); :}
			| (ReturnStmt) RETURN ExprOptional:ExprOpt SEMI {: RESULT=new ReturnStmt(ExprOpt); RESULT.setLine(ExprOptleft); :}
			| (ReadStmt) READ LPAREN Designator:designator RPAREN SEMI {: RESULT=new ReadStmt(designator); RESULT.setLine(designatorleft); :}
			| (PrintStmt) PRINT LPAREN Expr:expr NumConstOptional:numOpt RPAREN SEMI {: RESULT=new PrintStmt(expr, numOpt); RESULT.setLine(exprleft); :}
			| (ForEachStmt) Designator:designator DOT FOREACH LPAREN IDENT:ident LAMBDAOP Statement:stmt RPAREN SEMI {: RESULT=new ForEachStmt(designator, stmt); RESULT.setLine(designatorleft); :}
			| (StmtList) LBRACE StatementList:S1 RBRACE {: RESULT=new StmtList(S1); RESULT.setLine(S1left); :}
			| (ErrorStmtIFCondition) IF LPAREN error:err RPAREN
			{: parser.report_error("Izvrsen oporavak do ) (IF condition) u liniji " + errleft, null);  :} {: RESULT=new ErrorStmtIFCondition(); :}
			;

DesignatorStatement ::= (DesignatorStmtDef) Designator:D1 DesignatorStatementOptional:D2 SEMI {: RESULT=new DesignatorStmtDef(D1, D2); RESULT.setLine(D1left); :}
					| (DesignatorStmtAngleBrack) LANGLE DesignatorOptional:D1 DesignatorCommaList:D2 RANGLE EQUAL Designator:D3 SEMI {: RESULT=new DesignatorStmtAngleBrack(D1, D2, D3); RESULT.setLine(D1left); :}
					| (ErrorDesignatorStmtSEMI) error:err SEMI
					{: parser.report_error("Izvrsen oporavak do ; (DesignatorStmt) u liniji " + errleft, null);  :} {: RESULT=new ErrorDesignatorStmtSEMI(); :}
					;

ElseStatementOptional ::= (ElseStmtOpt) ELSE Statement:stmt {: RESULT=new ElseStmtOpt(stmt); RESULT.setLine(stmtleft); :}
						| (ElseStmtEpsilon) {: RESULT=new ElseStmtEpsilon(); :} /* epsilon */
						;

ExprOptional ::= (ExprOpt) Expr:expr {: RESULT=new ExprOpt(expr); RESULT.setLine(exprleft); :}
				| (NoExpr) {: RESULT=new NoExpr(); :} /* epsilon */
				;

NumConstOptional ::= (NumConstOpt) COMMA NUMBER:N1 {: RESULT=new NumConstOpt(N1); RESULT.setLine(N1left); :}
				| (NoNumConst) {: RESULT=new NoNumConst(); :} /* epsilon */
				;


DesignatorStatementOptional ::= (DesignatorStmtOptAssign) AssignOp:A1 Expr:expr {: RESULT=new DesignatorStmtOptAssign(A1, expr); RESULT.setLine(A1left); :}
							| (DesignatorStmtOptActPars) LPAREN ActParsOptional:A1 RPAREN {: RESULT=new DesignatorStmtOptActPars(A1); RESULT.setLine(A1left); :}
							| (DesignatorStmtOptINC) INC {: RESULT=new DesignatorStmtOptINC(); :}
							| (DesignatorStmtOptDEC) DEC {: RESULT=new DesignatorStmtOptDEC(); :};
							
ActParsOptional ::= (ActParsOpt) ActPars:A1 {: RESULT=new ActParsOpt(A1); RESULT.setLine(A1left); :}
				| (NoActParsOpt) {: RESULT=new NoActParsOpt(); :} /* epsilon */
				;

DesignatorOptional ::= (DesignatorOpt) Designator:D1 {: RESULT=new DesignatorOpt(D1); RESULT.setLine(D1left); :}
					| (NoDesignatorOpt) {: RESULT=new NoDesignatorOpt(); :} /* epsilon */
					;

DesignatorCommaList ::= (DesignatorCommaListDef) DesignatorCommaList:D1 COMMA DesignatorOptional:D2 {: RESULT=new DesignatorCommaListDef(D1, D2); RESULT.setLine(D1left); :}
					| (NoDesignatorCommaList) {: RESULT=new NoDesignatorCommaList(); :} /* epsilon */
					;



ActPars ::= (ActPars) Expr:expr ExprCommaList:E1 {: RESULT=new ActPars(expr, E1); RESULT.setLine(exprleft); :};

ExprCommaList ::= (ExprCommaListDef) ExprCommaList:E1 COMMA Expr:expr {: RESULT=new ExprCommaListDef(E1, expr); RESULT.setLine(E1left); :}
				| (NoExprCommaList) {: RESULT=new NoExprCommaList(); :} /* epsilon */
				;

Condition ::= (Condition) CondTerm:C1 CondTermList:C2 {: RESULT=new Condition(C1, C2); RESULT.setLine(C1left); :};

CondTermList ::= (CondTermListDef) CondTermList:C1 BITOR CondTerm:C2 {: RESULT=new CondTermListDef(C1, C2); RESULT.setLine(C1left); :}
				| (NoCondTermList) {: RESULT=new NoCondTermList(); :} /* epsilon */
				;

CondTerm ::= (CondTerm) CondFact:C1 CondFactList:C2 {: RESULT=new CondTerm(C1, C2); RESULT.setLine(C1left); :};

CondFactList ::= (CondFactListDef) CondFactList:C1 BITAND CondFact:C2 {: RESULT=new CondFactListDef(C1, C2); RESULT.setLine(C1left); :}
				| (NoCondFactList) {: RESULT=new NoCondFactList(); :} /* epsilon */
				;
				
CondFact ::= (CondFact) Expr:E1 RelOpExprOptional:R2 {: RESULT=new CondFact(E1, R2); RESULT.setLine(E1left); :};

RelOpExprOptional ::= (RelOpExprDef) RelOp:R1 Expr:E2 {: RESULT=new RelOpExprDef(R1, E2); RESULT.setLine(R1left); :}
					| (NoRelOpExpr) {: RESULT=new NoRelOpExpr(); :} /* epsilon */
					;



Expr ::= (Expr) MinusOptional:M1 Term:term AddOpTermList:A2 {: RESULT=new Expr(M1, term, A2); RESULT.setLine(M1left); :};

MinusOptional ::= (MinusDef) MINUS {: RESULT=new MinusDef(); :}
			| (NoMinus) {: RESULT=new NoMinus(); :} /* epsilon */
			;

AddOpTermList ::= (AddOpTermListDef) AddOpTermList:A1 AddOp:A2 Term:term {: RESULT=new AddOpTermListDef(A1, A2, term); RESULT.setLine(A1left); :}
				| (NoAddOpTermList) {: RESULT=new NoAddOpTermList(); :} /* epsilon */
				;



Term ::= (Term) Factor:factor MulOpFactorList:M1 {: RESULT=new Term(factor, M1); RESULT.setLine(factorleft); :};

MulOpFactorList ::= (MulOpFactorListDef) MulOpFactorList:M1 MulOp:M2 Factor:F3 {: RESULT=new MulOpFactorListDef(M1, M2, F3); RESULT.setLine(M1left); :}
				| (NoMulOpFactorList) {: RESULT=new NoMulOpFactorList(); :} /* epsilon */
				;



Factor ::= (FactorDesignator) Designator:designator ActParsParenOptional:A1 {: RESULT=new FactorDesignator(designator, A1); RESULT.setLine(designatorleft); :}
		| (FactorNumber) NUMBER:N1 {: RESULT=new FactorNumber(N1); RESULT.setLine(N1left); :}
		| (FactorChar) CHARCONST:C1 {: RESULT=new FactorChar(C1); RESULT.setLine(C1left); :}
		| (FactorBool) BOOLCONST:B1 {: RESULT=new FactorBool(B1); RESULT.setLine(B1left); :}
		| (FactorNew) NEW Type:typeName ExprOrActPars:E1 {: RESULT=new FactorNew(typeName, E1); RESULT.setLine(typeNameleft); :}
		| (FactorExpr) LPAREN Expr:expr RPAREN {: RESULT=new FactorExpr(expr); RESULT.setLine(exprleft); :};




ActParsParen ::= (ActParsParen) LPAREN ActParsOptional:A1 RPAREN {: RESULT=new ActParsParen(A1); RESULT.setLine(A1left); :};

ActParsParenOptional ::= (ActParsParenDef) ActParsParen:A1 {: RESULT=new ActParsParenDef(A1); RESULT.setLine(A1left); :}
						| (NoActParsParen) {: RESULT=new NoActParsParen(); :} /* epsilon */
						;

ExprOrActPars ::= (ExprOrActParsExpr) LANGLE Expr:expr RANGLE {: RESULT=new ExprOrActParsExpr(expr); RESULT.setLine(exprleft); :}
				| (ExprOrActParsActPars) LPAREN ActParsOptional:A1 RPAREN {: RESULT=new ExprOrActParsActPars(A1); RESULT.setLine(A1left); :};


Designator ::= (DesignatorIdent) IDENT:ident {: RESULT=new DesignatorIdent(); :}
			| (DesignatorDotIdent) Designator:designator DOT IDENT:ident {: RESULT=new DesignatorDotIdent(designator); RESULT.setLine(designatorleft); :}
			| (DesignatorExpr) Designator:designator LANGLE Expr:E1 RANGLE {: RESULT=new DesignatorExpr(designator, E1); RESULT.setLine(designatorleft); :}
			;

Label ::= (Label) IDENT:ident {: RESULT=new Label(); :};
AssignOp ::= (AssignOp) EQUAL {: RESULT=new AssignOp(); :};
RelOp ::= (RelEQ) EQ {: RESULT=new RelEQ(); :} | (RelNEQ) NEQ {: RESULT=new RelNEQ(); :} | (RelGT) GT {: RESULT=new RelGT(); :} | (RelGEQ) GEQ {: RESULT=new RelGEQ(); :} | (RelLT) LT {: RESULT=new RelLT(); :} | (RelLEQ) LEQ {: RESULT=new RelLEQ(); :};
AddOp ::= (AddPLUS) PLUS {: RESULT=new AddPLUS(); :} | (AddMINUS) MINUS {: RESULT=new AddMINUS(); :};
MulOp ::= (MulMUL) MUL {: RESULT=new MulMUL(); :} | (MulDIV) DIV {: RESULT=new MulDIV(); :} | (MulMOD) MOD {: RESULT=new MulMOD(); :};


