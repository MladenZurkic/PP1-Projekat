package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, BREAK, CLASS, ENUM, ELSE, CONST, IF, DO, WHILE, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE;
terminal THIS, FOREACH, IDENT, NUMBER, CHARCONST, BOOLCONST, PLUS, MINUS, MUL, DIV, MOD, EQ, NEQ;
terminal GT, GEQ, LT, LEQ, BITAND, BITOR, EQUAL, INC, DEC, SEMI, COLON, COMMA, DOT, LPAREN, RPAREN, LANGLE;
terminal RANGLE, LBRACE, RBRACE, LAMBDAOP;

nonterminal Program Program;
nonterminal DeclsList DeclsList;
nonterminal Decls Decls;
nonterminal MethodDeclList MethodDeclList;
nonterminal ConstDecl ConstDecl;
nonterminal Consts Consts;
nonterminal ConstsList ConstsList;
nonterminal Type Type;
nonterminal VarDecl VarDecl;
nonterminal AngleBrackets AngleBrackets;
nonterminal MoreVarDecls MoreVarDecls;
nonterminal ClassDecl ClassDecl;
nonterminal ClassConstrMethodDecl ClassConstrMethodDecl;
nonterminal ExtendsOptional ExtendsOptional;
nonterminal VarDeclList VarDeclList;
nonterminal ConstructorDeclList ConstructorDeclList;
nonterminal ConstructorDecl ConstructorDecl;
nonterminal FormParsOptional FormParsOptional;
nonterminal StatementList StatementList;
nonterminal FormPars FormPars;
nonterminal FormParsList FormParsList;
nonterminal MethodDecl MethodDecl;
nonterminal TypeOrVoid TypeOrVoid;
nonterminal Statement Statement;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ElseStatementOptional ElseStatementOptional;
nonterminal ExprOptional ExprOptional;
nonterminal NumConstOptional NumConstOptional;
nonterminal DesignatorStatementOptional DesignatorStatementOptional;
nonterminal ActParsOptional ActParsOptional;
nonterminal DesignatorOptional DesignatorOptional;
nonterminal DesignatorCommaList DesignatorCommaList;
nonterminal ActPars ActPars;
nonterminal ExprCommaList ExprCommaList;
nonterminal Condition Condition;
nonterminal CondTermList CondTermList;
nonterminal CondTerm CondTerm;
nonterminal CondFactList CondFactList;
nonterminal CondFact CondFact;
nonterminal RelOpExprOptional RelOpExprOptional;
nonterminal Expr Expr;
nonterminal MinusOptional MinusOptional;
nonterminal AddOpTermList AddOpTermList;
nonterminal Term Term;
nonterminal MulOpFactorList MulOpFactorList;
nonterminal Factor Factor;
nonterminal ActParsParen ActParsParen;
nonterminal ActParsParenOptional ActParsParenOptional;
nonterminal ExprOrActPars ExprOrActPars;
nonterminal Designator Designator;
nonterminal DesignatorList DesignatorList;
nonterminal DesignatorElem DesignatorElem;
nonterminal Label Label;
nonterminal AssignOp AssignOp;
nonterminal RelOp RelOp;
nonterminal AddOp AddOp;
nonterminal MulOp MulOp;
nonterminal ConstrMethodBothOptional ConstrMethodBothOptional;
nonterminal ConstrMethodModif ConstrMethodModif;
nonterminal MethodDeclModif MethodDeclModif;
nonterminal MethodDeclListV2 MethodDeclListV2;
nonterminal ConstrDeclModif ConstrDeclModif;
nonterminal ConstrDeclListV2 ConstrDeclListV2;
nonterminal ConstMethodSecondPart ConstMethodSecondPart;
nonterminal MethodRest MethodRest;


precedence left ELSE;

Program ::= (Program) PROG IDENT DeclsList:D1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(D1, M2); RESULT.setLine(D1left); :};

DeclsList ::= (Declarations) DeclsList:D1 Decls:D2 {: RESULT=new Declarations(D1, D2); RESULT.setLine(D1left); :}
			| 
			(NoVarDecl) {: RESULT=new NoVarDecl(); :} /* epsilon */
			;

Decls ::= (DeclsConstDecl) ConstDecl:C1 {: RESULT=new DeclsConstDecl(C1); RESULT.setLine(C1left); :}
		| (DeclsVarDecl) VarDecl:V1 {: RESULT=new DeclsVarDecl(V1); RESULT.setLine(V1left); :}
		| (DeclsClassDecl) ClassDecl:C1 {: RESULT=new DeclsClassDecl(C1); RESULT.setLine(C1left); :};

MethodDeclList ::= MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclListDerived1(M1, M2); RESULT.setLine(M1left); :}  
				| {: RESULT=new MethodDeclListDerived2(); :}
				;

ConstDecl ::= CONST Type:T1 IDENT EQUAL Consts:C2 ConstsList:C3 SEMI {: RESULT=new ConstDeclDerived1(T1, C2, C3); RESULT.setLine(T1left); :};

Consts ::= NUMBER {: RESULT=new ConstsDerived1(); :}
		| CHARCONST {: RESULT=new ConstsDerived2(); :}
		| BOOLCONST {: RESULT=new ConstsDerived3(); :};
		
ConstsList ::= ConstsList:C1 COMMA IDENT EQUAL Consts:C2 {: RESULT=new ConstsListDerived1(C1, C2); RESULT.setLine(C1left); :}
			| {: RESULT=new ConstsListDerived2(); :}
			;

Type ::= IDENT {: RESULT=new TypeDerived1(); :};

VarDecl ::= Type:T1 IDENT AngleBrackets:A2 MoreVarDecls:M3 SEMI {: RESULT=new VarDeclDerived1(T1, A2, M3); RESULT.setLine(T1left); :};

AngleBrackets ::= LANGLE RANGLE {: RESULT=new AngleBracketsDerived1(); :}
				| {: RESULT=new AngleBracketsDerived2(); :}
				;

MoreVarDecls ::= MoreVarDecls:M1 COMMA IDENT AngleBrackets:A2 {: RESULT=new MoreVarDeclsDerived1(M1, A2); RESULT.setLine(M1left); :}
			| {: RESULT=new MoreVarDeclsDerived2(); :}
			;
			
ClassDecl ::= CLASS IDENT ExtendsOptional:E1 LBRACE VarDeclList:V2 ClassConstrMethodDecl:C3 RBRACE {: RESULT=new ClassDeclDerived1(E1, V2, C3); RESULT.setLine(E1left); :};

ExtendsOptional ::= EXTENDS Type:T1 {: RESULT=new ExtendsOptionalDerived1(T1); RESULT.setLine(T1left); :}
			| {: RESULT=new ExtendsOptionalDerived2(); :}
			;

VarDeclList ::= VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclListDerived1(V1, V2); RESULT.setLine(V1left); :}
			| {: RESULT=new VarDeclListDerived2(); :}
			;
			
ClassConstrMethodDecl ::= LBRACE ConstrMethodBothOptional:C1 RBRACE {: RESULT=new ClassConstrMethodDeclDerived1(C1); RESULT.setLine(C1left); :}
						| {: RESULT=new ClassConstrMethodDeclDerived2(); :}
						;

ConstrMethodBothOptional ::= IDENT ConstMethodSecondPart:C1 ConstrMethodBothOptional:C2 {: RESULT=new ConstrMethodBothOptionalDerived1(C1, C2); RESULT.setLine(C1left); :}
							| IDENT IDENT ConstMethodSecondPart:C1 MethodRest:M2 {: RESULT=new ConstrMethodBothOptionalDerived2(C1, M2); RESULT.setLine(C1left); :}
							| VOID IDENT ConstMethodSecondPart:C1 MethodRest:M2 {: RESULT=new ConstrMethodBothOptionalDerived3(C1, M2); RESULT.setLine(C1left); :}
							| {: RESULT=new ConstrMethodBothOptionalDerived4(); :}
							;

ConstMethodSecondPart ::= LPAREN FormParsOptional:F1 RPAREN VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new ConstMethodSecondPartDerived1(F1, V2, S3); RESULT.setLine(F1left); :};

MethodRest ::= IDENT IDENT ConstMethodSecondPart:C1 MethodRest:M2 {: RESULT=new MethodRestDerived1(C1, M2); RESULT.setLine(C1left); :}
			| VOID IDENT ConstMethodSecondPart:C1 MethodRest:M2 {: RESULT=new MethodRestDerived2(C1, M2); RESULT.setLine(C1left); :}
			| {: RESULT=new MethodRestDerived3(); :}
			;


ConstrMethodModif ::= ConstrDeclModif:C1 MethodDeclModif:M2 {: RESULT=new ConstrMethodModifDerived1(C1, M2); RESULT.setLine(C1left); :}
					|  MethodDeclModif:M1 {: RESULT=new ConstrMethodModifDerived2(M1); RESULT.setLine(M1left); :};

				
ConstrDeclModif ::= LPAREN FormParsOptional:F1 RPAREN VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new ConstrDeclModifDerived1(F1, V2, S3); RESULT.setLine(F1left); :};

MethodDeclModif ::= IDENT LPAREN FormParsOptional:F1 RPAREN VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new MethodDeclModifDerived1(F1, V2, S3); RESULT.setLine(F1left); :};

ConstructorDecl ::= IDENT LPAREN FormParsOptional:F1 RPAREN VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new ConstructorDeclDerived1(F1, V2, S3); RESULT.setLine(F1left); :};

FormParsOptional ::= FormPars:F1 {: RESULT=new FormParsOptionalDerived1(F1); RESULT.setLine(F1left); :}
					| {: RESULT=new FormParsOptionalDerived2(); :}
					;
					
StatementList ::= StatementList:S1 Statement:S2 {: RESULT=new StatementListDerived1(S1, S2); RESULT.setLine(S1left); :}
				| {: RESULT=new StatementListDerived2(); :}
				;

FormPars ::= Type:T1 IDENT AngleBrackets:A2 FormParsList:F3 {: RESULT=new FormParsDerived1(T1, A2, F3); RESULT.setLine(T1left); :};

FormParsList ::= FormParsList:F1 COMMA Type:T2 IDENT AngleBrackets:A3 {: RESULT=new FormParsListDerived1(F1, T2, A3); RESULT.setLine(F1left); :}
				| {: RESULT=new FormParsListDerived2(); :}
				;
				
MethodDecl ::= TypeOrVoid:T1 IDENT LPAREN FormParsOptional:F2 RPAREN VarDeclList:V3 LBRACE StatementList:S4 RBRACE {: RESULT=new MethodDeclDerived1(T1, F2, V3, S4); RESULT.setLine(T1left); :};

TypeOrVoid ::= Type:T1 {: RESULT=new TypeOrVoidDerived1(T1); RESULT.setLine(T1left); :}
			| VOID {: RESULT=new TypeOrVoidDerived2(); :};

Statement ::= DesignatorStatement:D1 SEMI {: RESULT=new StatementDerived1(D1); RESULT.setLine(D1left); :}
			| IF LPAREN Condition:C1 RPAREN Statement:S2 ElseStatementOptional:E3 {: RESULT=new StatementDerived2(C1, S2, E3); RESULT.setLine(C1left); :}
			| WHILE LPAREN Condition:C1 RPAREN Statement:S2 {: RESULT=new StatementDerived3(C1, S2); RESULT.setLine(C1left); :}
			| BREAK SEMI {: RESULT=new StatementDerived4(); :}
			| CONTINUE SEMI {: RESULT=new StatementDerived5(); :}
			| RETURN ExprOptional:E1 SEMI {: RESULT=new StatementDerived6(E1); RESULT.setLine(E1left); :}
			| READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new StatementDerived7(D1); RESULT.setLine(D1left); :}
			| PRINT LPAREN Expr:E1 NumConstOptional:N2 RPAREN SEMI {: RESULT=new StatementDerived8(E1, N2); RESULT.setLine(E1left); :}
			| Designator:D1 DOT FOREACH LPAREN IDENT LAMBDAOP Statement:S2 RPAREN SEMI {: RESULT=new StatementDerived9(D1, S2); RESULT.setLine(D1left); :}
			| LBRACE StatementList:S1 RBRACE {: RESULT=new StatementDerived10(S1); RESULT.setLine(S1left); :};

DesignatorStatement ::= Designator:D1 DesignatorStatementOptional:D2 {: RESULT=new DesignatorStatementDerived1(D1, D2); RESULT.setLine(D1left); :}
					| LANGLE DesignatorOptional:D1 DesignatorCommaList:D2 RANGLE EQUAL Designator:D3 {: RESULT=new DesignatorStatementDerived2(D1, D2, D3); RESULT.setLine(D1left); :};

ElseStatementOptional ::= ELSE Statement:S1 {: RESULT=new ElseStatementOptionalDerived1(S1); RESULT.setLine(S1left); :}
						| {: RESULT=new ElseStatementOptionalDerived2(); :}
						;

ExprOptional ::= Expr:E1 {: RESULT=new ExprOptionalDerived1(E1); RESULT.setLine(E1left); :}
				| {: RESULT=new ExprOptionalDerived2(); :}
				;

NumConstOptional ::= COMMA NUMBER {: RESULT=new NumConstOptionalDerived1(); :}
				| {: RESULT=new NumConstOptionalDerived2(); :}
				;




DesignatorStatementOptional ::= AssignOp:A1 Expr:E2 {: RESULT=new DesignatorStatementOptionalDerived1(A1, E2); RESULT.setLine(A1left); :}
							| LPAREN ActParsOptional:A1 RPAREN {: RESULT=new DesignatorStatementOptionalDerived2(A1); RESULT.setLine(A1left); :}
							| INC {: RESULT=new DesignatorStatementOptionalDerived3(); :}
							| DEC {: RESULT=new DesignatorStatementOptionalDerived4(); :};
							
ActParsOptional ::= ActPars:A1 {: RESULT=new ActParsOptionalDerived1(A1); RESULT.setLine(A1left); :}
				| {: RESULT=new ActParsOptionalDerived2(); :}
				;

DesignatorOptional ::= Designator:D1 {: RESULT=new DesignatorOptionalDerived1(D1); RESULT.setLine(D1left); :}
					| {: RESULT=new DesignatorOptionalDerived2(); :}
					;

DesignatorCommaList ::= DesignatorCommaList:D1 COMMA DesignatorOptional:D2 {: RESULT=new DesignatorCommaListDerived1(D1, D2); RESULT.setLine(D1left); :}
					| {: RESULT=new DesignatorCommaListDerived2(); :}
					;



ActPars ::= Expr:E1 ExprCommaList:E2 {: RESULT=new ActParsDerived1(E1, E2); RESULT.setLine(E1left); :};

ExprCommaList ::= ExprCommaList:E1 COMMA Expr:E2 {: RESULT=new ExprCommaListDerived1(E1, E2); RESULT.setLine(E1left); :}
				| {: RESULT=new ExprCommaListDerived2(); :}
				;

Condition ::= CondTerm:C1 CondTermList:C2 {: RESULT=new ConditionDerived1(C1, C2); RESULT.setLine(C1left); :};

CondTermList ::= CondTermList:C1 BITOR CondTerm:C2 {: RESULT=new CondTermListDerived1(C1, C2); RESULT.setLine(C1left); :}
				| {: RESULT=new CondTermListDerived2(); :}
				;

CondTerm ::= CondFact:C1 CondFactList:C2 {: RESULT=new CondTermDerived1(C1, C2); RESULT.setLine(C1left); :};

CondFactList ::= CondFactList:C1 BITAND CondFact:C2 {: RESULT=new CondFactListDerived1(C1, C2); RESULT.setLine(C1left); :}
				| {: RESULT=new CondFactListDerived2(); :}
				;
				
CondFact ::= Expr:E1 RelOpExprOptional:R2 {: RESULT=new CondFactDerived1(E1, R2); RESULT.setLine(E1left); :};

RelOpExprOptional ::= RelOp:R1 Expr:E2 {: RESULT=new RelOpExprOptionalDerived1(R1, E2); RESULT.setLine(R1left); :}
					| {: RESULT=new RelOpExprOptionalDerived2(); :}
					;



Expr ::= MinusOptional:M1 Term:T2 AddOpTermList:A3 {: RESULT=new ExprDerived1(M1, T2, A3); RESULT.setLine(M1left); :};

MinusOptional ::= MINUS {: RESULT=new MinusOptionalDerived1(); :}
			| {: RESULT=new MinusOptionalDerived2(); :}
			;

AddOpTermList ::= AddOpTermList:A1 AddOp:A2 Term:T3 {: RESULT=new AddOpTermListDerived1(A1, A2, T3); RESULT.setLine(A1left); :}
				| {: RESULT=new AddOpTermListDerived2(); :}
				;



Term ::= Factor:F1 MulOpFactorList:M2 {: RESULT=new TermDerived1(F1, M2); RESULT.setLine(F1left); :};

MulOpFactorList ::= MulOpFactorList:M1 MulOp:M2 Factor:F3 {: RESULT=new MulOpFactorListDerived1(M1, M2, F3); RESULT.setLine(M1left); :}
				| {: RESULT=new MulOpFactorListDerived2(); :}
				;



Factor ::= Designator:D1 ActParsParenOptional:A2 {: RESULT=new FactorDerived1(D1, A2); RESULT.setLine(D1left); :}
		| NUMBER {: RESULT=new FactorDerived2(); :}
		| CHARCONST {: RESULT=new FactorDerived3(); :}
		| BOOLCONST {: RESULT=new FactorDerived4(); :}
		| NEW Type:T1 ExprOrActPars:E2 {: RESULT=new FactorDerived5(T1, E2); RESULT.setLine(T1left); :}
		| LPAREN Expr:E1 RPAREN {: RESULT=new FactorDerived6(E1); RESULT.setLine(E1left); :};




ActParsParen ::= LPAREN ActParsOptional:A1 RPAREN {: RESULT=new ActParsParenDerived1(A1); RESULT.setLine(A1left); :};

ActParsParenOptional ::= ActParsParen:A1 {: RESULT=new ActParsParenOptionalDerived1(A1); RESULT.setLine(A1left); :}
						| {: RESULT=new ActParsParenOptionalDerived2(); :}
						;

ExprOrActPars ::= LANGLE Expr:E1 RANGLE {: RESULT=new ExprOrActParsDerived1(E1); RESULT.setLine(E1left); :}
				| LPAREN ActParsOptional:A1 RPAREN {: RESULT=new ExprOrActParsDerived2(A1); RESULT.setLine(A1left); :};



Designator ::= IDENT {: RESULT=new DesignatorDerived1(); :}
			| Designator:D1 DOT IDENT {: RESULT=new DesignatorDerived2(D1); RESULT.setLine(D1left); :}
			| Designator:D1 LANGLE Expr:E2 RANGLE {: RESULT=new DesignatorDerived3(D1, E2); RESULT.setLine(D1left); :}
			;
/*
DesignatorList ::= DesignatorList DesignatorElem;

DesignatorElem ::= DOT IDENT
				| LANGLE Expr RANGLE;
*/


Label ::= IDENT {: RESULT=new LabelDerived1(); :};
AssignOp ::= EQUAL {: RESULT=new AssignOpDerived1(); :};
RelOp ::= EQ {: RESULT=new RelOpDerived1(); :} | NEQ {: RESULT=new RelOpDerived2(); :} | GT {: RESULT=new RelOpDerived3(); :} | GEQ {: RESULT=new RelOpDerived4(); :} | LT {: RESULT=new RelOpDerived5(); :} | LEQ {: RESULT=new RelOpDerived6(); :};
AddOp ::= PLUS {: RESULT=new AddOpDerived1(); :} | MINUS {: RESULT=new AddOpDerived2(); :};
MulOp ::= MUL {: RESULT=new MulOpDerived1(); :} | DIV {: RESULT=new MulOpDerived2(); :} | MOD {: RESULT=new MulOpDerived3(); :};


