package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, BREAK, CLASS, ELSE, CONST, IF, WHILE, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE;
terminal FOREACH, IDENT, PLUS, MINUS, MUL, DIV, MOD, EQ, NEQ;
terminal GT, GEQ, LT, LEQ, BITAND, BITOR, EQUAL, INC, DEC, SEMI, COMMA, DOT, LPAREN, RPAREN, LANGLE;
terminal RANGLE, LBRACE, RBRACE, LAMBDAOP;
terminal  DO, ENUM, COLON;
terminal Integer NUMBER;
terminal Character CHARCONST;
terminal Boolean BOOLCONST;

nonterminal Program Program;
nonterminal DeclsList DeclsList;
nonterminal Decls Decls;
nonterminal MethodDeclList MethodDeclList;
nonterminal ConstDecl ConstDecl;
nonterminal Consts Consts;
nonterminal ConstsList ConstsList;
nonterminal Type Type;
nonterminal VarDecl VarDecl;
nonterminal AngleBrackets AngleBrackets;
nonterminal MoreVarDecls MoreVarDecls;
nonterminal ClassDecl ClassDecl;
nonterminal ClassConstrMethodDecl ClassConstrMethodDecl;
nonterminal ExtendsOptional ExtendsOptional;
nonterminal VarDeclList VarDeclList;
nonterminal ConstMethodSecondPart ConstMethodSecondPart;
nonterminal MethodRest MethodRest;
nonterminal ConstructorDecl ConstructorDecl;
nonterminal FormParsOptional FormParsOptional;
nonterminal StatementList StatementList;
nonterminal FormPars FormPars;
nonterminal FormParsList FormParsList;
nonterminal MethodDecl MethodDecl;
nonterminal TypeOrVoid TypeOrVoid;
nonterminal Statement Statement;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ElseStatementOptional ElseStatementOptional;
nonterminal ExprOptional ExprOptional;
nonterminal NumConstOptional NumConstOptional;
nonterminal DesignatorStatementOptional DesignatorStatementOptional;
nonterminal ActParsOptional ActParsOptional;
nonterminal DesignatorOptional DesignatorOptional;
nonterminal DesignatorCommaList DesignatorCommaList;
nonterminal ActPars ActPars;
nonterminal ExprCommaList ExprCommaList;
nonterminal Condition Condition;
nonterminal CondTermList CondTermList;
nonterminal CondTerm CondTerm;
nonterminal CondFactList CondFactList;
nonterminal CondFact CondFact;
nonterminal RelOpExprOptional RelOpExprOptional;
nonterminal Expr Expr;
nonterminal MinusOptional MinusOptional;
nonterminal AddOpTermList AddOpTermList;
nonterminal Term Term;
nonterminal MulOpFactorList MulOpFactorList;
nonterminal Factor Factor;
nonterminal ActParsParen ActParsParen;
nonterminal ActParsParenOptional ActParsParenOptional;
nonterminal ExprOrActPars ExprOrActPars;
nonterminal Designator Designator;
nonterminal Label Label;
nonterminal AssignOp AssignOp;
nonterminal RelOp RelOp;
nonterminal AddOp AddOp;
nonterminal MulOp MulOp;
nonterminal ConstrMethodBothOptional ConstrMethodBothOptional;
nonterminal ConstsListElem ConstsListElem;
nonterminal VarDeclErrorPossible VarDeclErrorPossible;
nonterminal FormParsEnd FormParsEnd;
nonterminal FormParsIdent FormParsIdent;

/*nonterminal DesignatorElem, DesignatorList*/

nonterminal VarDeclListBasic VarDeclListBasic;
nonterminal VarDeclComma VarDeclComma;
nonterminal VarDeclEnd VarDeclEnd;
nonterminal VarDeclIdent VarDeclIdent;

precedence left ELSE;

Program ::= (Program) PROG IDENT DeclsList:D1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(D1, M2); RESULT.setLine(D1left); :};

DeclsList ::= (Declarations) DeclsList:D1 Decls:D2 {: RESULT=new Declarations(D1, D2); RESULT.setLine(D1left); :}
			| 
			(NoVarDecl) {: RESULT=new NoVarDecl(); :} /* epsilon */
			;

Decls ::= (DeclsConstDecl) ConstDecl:C1 {: RESULT=new DeclsConstDecl(C1); RESULT.setLine(C1left); :}
		| (DeclsVarDecl) VarDeclErrorPossible:V1 {: RESULT=new DeclsVarDecl(V1); RESULT.setLine(V1left); :}
		| (DeclsClassDecl) ClassDecl:C1 {: RESULT=new DeclsClassDecl(C1); RESULT.setLine(C1left); :};



MethodDeclList ::= MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclListDerived1(M1, M2); RESULT.setLine(M1left); :}  
				| (NoMethodDeclList) {: RESULT=new NoMethodDeclList(); :} /* epsilon */
				;

ConstDecl ::= (ConstDeclDef) CONST Type:T1 ConstsList:C2 SEMI {: RESULT=new ConstDeclDef(T1, C2); RESULT.setLine(T1left); :};
			

Consts ::= (ConstsNumber) NUMBER:N1 {: RESULT=new ConstsNumber(N1); RESULT.setLine(N1left); :}
		| (ConstsCharConst) CHARCONST:C1 {: RESULT=new ConstsCharConst(C1); RESULT.setLine(C1left); :}
		| (ConstsBoolConst) BOOLCONST:B1 {: RESULT=new ConstsBoolConst(B1); RESULT.setLine(B1left); :};
		
ConstsList ::= (ConstsListDef) ConstsList:C1 COMMA ConstsListElem:C2 {: RESULT=new ConstsListDef(C1, C2); RESULT.setLine(C1left); :}
			| (ConstsListElemInList) ConstsListElem:C1 {: RESULT=new ConstsListElemInList(C1); RESULT.setLine(C1left); :}
			;
			
ConstsListElem ::= (ConstsListElem) IDENT:id EQUAL Consts:value {: RESULT=new ConstsListElem(value); RESULT.setLine(valueleft); :};

Type ::= (Type) IDENT {: RESULT=new Type(); :};

VarDecl ::= (DefVarDecl) Type:T1 VarDeclIdent:V2 MoreVarDecls:M3 SEMI {: RESULT=new DefVarDecl(T1, V2, M3); RESULT.setLine(T1left); :};

VarDeclErrorPossible ::= (VarDeclErrorPossible) Type:T1 VarDeclListBasic:V2 {: RESULT=new VarDeclErrorPossible(T1, V2); RESULT.setLine(T1left); :};

VarDeclListBasic ::= VarDeclComma:V1 VarDeclListBasic:V2 {: RESULT=new VarDeclListBasicDerived1(V1, V2); RESULT.setLine(V1left); :}
				| VarDeclEnd:V1 {: RESULT=new VarDeclListBasicDerived2(V1); RESULT.setLine(V1left); :};


VarDeclComma ::= (VarDeclCommaDef) VarDeclIdent:V1 COMMA {: RESULT=new VarDeclCommaDef(V1); RESULT.setLine(V1left); :}
				| (ErrorVarDeclListBasic) error:err COMMA
				{: parser.report_error("Izvrsen oporavak do , (VarDeclComma) u liniji " + errleft, null);  :} {: RESULT=new ErrorVarDeclListBasic(); :}
				;

VarDeclEnd ::= (VarDeclEndDef) VarDeclIdent:V1 SEMI {: RESULT=new VarDeclEndDef(V1); RESULT.setLine(V1left); :}
			| (ErrorVarDecl) error:err SEMI
			{: parser.report_error("Izvrsen oporavak do ; (VarDeclEnd) u liniji " + errleft, null);  :} {: RESULT=new ErrorVarDecl(); :}
			;

VarDeclIdent ::= (VarDeclIdent) IDENT AngleBrackets:A1 {: RESULT=new VarDeclIdent(A1); RESULT.setLine(A1left); :};


AngleBrackets ::= (AngleBrackets) LANGLE RANGLE {: RESULT=new AngleBrackets(); :}
				| (NoAngleBrackets) {: RESULT=new NoAngleBrackets(); :}
				;

MoreVarDecls ::= (MoreVarDeclsDef) MoreVarDecls:M1 COMMA VarDeclIdent:V2 {: RESULT=new MoreVarDeclsDef(M1, V2); RESULT.setLine(M1left); :}
			| {: RESULT=new MoreVarDeclsDerived1(); :}
			;
			
ClassDecl ::= (ClassDecl) CLASS IDENT ExtendsOptional:E1 LBRACE VarDeclList:V2 ClassConstrMethodDecl:C3 RBRACE {: RESULT=new ClassDecl(E1, V2, C3); RESULT.setLine(E1left); :};

ExtendsOptional ::= (ExtendsOptionalDef) EXTENDS Type:T1 {: RESULT=new ExtendsOptionalDef(T1); RESULT.setLine(T1left); :}
			| (ExtendsOptionalEpsilon) {: RESULT=new ExtendsOptionalEpsilon(); :}
			;

VarDeclList ::= (VarDeclsList) VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclsList(V1, V2); RESULT.setLine(V1left); :}
			| (VarDeclsListEpsilon) {: RESULT=new VarDeclsListEpsilon(); :}
			;
			
ClassConstrMethodDecl ::= LBRACE ConstrMethodBothOptional:C1 RBRACE {: RESULT=new ClassConstrMethodDeclDerived1(C1); RESULT.setLine(C1left); :}
						| {: RESULT=new ClassConstrMethodDeclDerived2(); :}
						;

ConstrMethodBothOptional ::= IDENT ConstMethodSecondPart:C1 ConstrMethodBothOptional:C2 {: RESULT=new ConstrMethodBothOptionalDerived1(C1, C2); RESULT.setLine(C1left); :}
							| IDENT IDENT ConstMethodSecondPart:C1 MethodRest:M2 {: RESULT=new ConstrMethodBothOptionalDerived2(C1, M2); RESULT.setLine(C1left); :}
							| VOID IDENT ConstMethodSecondPart:C1 MethodRest:M2 {: RESULT=new ConstrMethodBothOptionalDerived3(C1, M2); RESULT.setLine(C1left); :}
							| {: RESULT=new ConstrMethodBothOptionalDerived4(); :}
							;

ConstMethodSecondPart ::= LPAREN FormParsOptional:F1 VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new ConstMethodSecondPartDerived1(F1, V2, S3); RESULT.setLine(F1left); :};

MethodRest ::= IDENT IDENT ConstMethodSecondPart:C1 MethodRest:M2 {: RESULT=new MethodRestDerived1(C1, M2); RESULT.setLine(C1left); :}
			| VOID IDENT ConstMethodSecondPart:C1 MethodRest:M2 {: RESULT=new MethodRestDerived2(C1, M2); RESULT.setLine(C1left); :}
			| {: RESULT=new MethodRestDerived3(); :}
			;

ConstructorDecl ::= IDENT LPAREN FormParsOptional:F1 VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new ConstructorDeclDerived1(F1, V2, S3); RESULT.setLine(F1left); :};

FormParsOptional ::= FormPars:F1 {: RESULT=new FormParsOptionalDerived1(F1); RESULT.setLine(F1left); :}
					| RPAREN {: RESULT=new FormParsOptionalDerived2(); :}
					;
					
StatementList ::= StatementList:S1 Statement:S2 {: RESULT=new StatementListDerived1(S1, S2); RESULT.setLine(S1left); :}
				| {: RESULT=new StatementListDerived2(); :}
				;

FormPars ::= FormParsList:F1 FormPars:F2 {: RESULT=new FormParsDerived1(F1, F2); RESULT.setLine(F1left); :}
			| FormParsEnd:F1 {: RESULT=new FormParsDerived2(F1); RESULT.setLine(F1left); :}
			;

FormParsList ::= FormParsIdent:F1 COMMA {: RESULT=new FormParsListDerived1(F1); RESULT.setLine(F1left); :}
				| error:err COMMA
				{: parser.report_error("Izvrsen oporavak do , (FormParsList) u liniji " + errleft, null);  :} {: RESULT=new FormParsListDerived2(); :}
				;
				
FormParsEnd ::= FormParsIdent:F1 RPAREN {: RESULT=new FormParsEndDerived1(F1); RESULT.setLine(F1left); :}
			| error:err RPAREN
			{: parser.report_error("Izvrsen oporavak do ) (FormParsEnd) u liniji " + errleft, null);  :} {: RESULT=new FormParsEndDerived2(); :}
			;
			
FormParsIdent ::= Type:T1 IDENT AngleBrackets:A2 {: RESULT=new FormParsIdentDerived1(T1, A2); RESULT.setLine(T1left); :};
				
MethodDecl ::= TypeOrVoid:T1 IDENT LPAREN FormParsOptional:F2 VarDeclList:V3 LBRACE StatementList:S4 RBRACE {: RESULT=new MethodDeclDerived1(T1, F2, V3, S4); RESULT.setLine(T1left); :};

TypeOrVoid ::= Type:T1 {: RESULT=new TypeOrVoidDerived1(T1); RESULT.setLine(T1left); :}
			| VOID {: RESULT=new TypeOrVoidDerived2(); :};

Statement ::= DesignatorStatement:D1 {: RESULT=new StatementDerived1(D1); RESULT.setLine(D1left); :}
			| IF LPAREN Condition:C1 RPAREN Statement:S2 ElseStatementOptional:E3 {: RESULT=new StatementDerived2(C1, S2, E3); RESULT.setLine(C1left); :}
			| WHILE LPAREN Condition:C1 RPAREN Statement:S2 {: RESULT=new StatementDerived3(C1, S2); RESULT.setLine(C1left); :}
			| BREAK SEMI {: RESULT=new StatementDerived4(); :}
			| CONTINUE SEMI {: RESULT=new StatementDerived5(); :}
			| RETURN ExprOptional:E1 SEMI {: RESULT=new StatementDerived6(E1); RESULT.setLine(E1left); :}
			| READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new StatementDerived7(D1); RESULT.setLine(D1left); :}
			| (PrintStmt) PRINT LPAREN Expr:E1 NumConstOptional:N2 RPAREN SEMI {: RESULT=new PrintStmt(E1, N2); RESULT.setLine(E1left); :}
			| Designator:D1 DOT FOREACH LPAREN IDENT LAMBDAOP Statement:S2 RPAREN SEMI {: RESULT=new StatementDerived8(D1, S2); RESULT.setLine(D1left); :}
			| LBRACE StatementList:S1 RBRACE {: RESULT=new StatementDerived9(S1); RESULT.setLine(S1left); :}
			| IF LPAREN error:err RPAREN
			{: parser.report_error("Izvrsen oporavak do ) (IF condition) u liniji " + errleft, null);  :} {: RESULT=new StatementDerived10(); :}
			;

DesignatorStatement ::= Designator:D1 DesignatorStatementOptional:D2 SEMI {: RESULT=new DesignatorStatementDerived1(D1, D2); RESULT.setLine(D1left); :}
					| LANGLE DesignatorOptional:D1 DesignatorCommaList:D2 RANGLE EQUAL Designator:D3 SEMI {: RESULT=new DesignatorStatementDerived2(D1, D2, D3); RESULT.setLine(D1left); :}
					| error:err SEMI
					{: parser.report_error("Izvrsen oporavak do ; (DesignatorStmt) u liniji " + errleft, null);  :} {: RESULT=new DesignatorStatementDerived3(); :}
					;

ElseStatementOptional ::= ELSE Statement:S1 {: RESULT=new ElseStatementOptionalDerived1(S1); RESULT.setLine(S1left); :}
						| {: RESULT=new ElseStatementOptionalDerived2(); :}
						;

ExprOptional ::= Expr:E1 {: RESULT=new ExprOptionalDerived1(E1); RESULT.setLine(E1left); :}
				| {: RESULT=new ExprOptionalDerived2(); :}
				;

NumConstOptional ::= COMMA NUMBER:N1 {: RESULT=new NumConstOptionalDerived1(N1); RESULT.setLine(N1left); :}
				| {: RESULT=new NumConstOptionalDerived2(); :}
				;




DesignatorStatementOptional ::= AssignOp:A1 Expr:E2 {: RESULT=new DesignatorStatementOptionalDerived1(A1, E2); RESULT.setLine(A1left); :}
							| LPAREN ActParsOptional:A1 RPAREN {: RESULT=new DesignatorStatementOptionalDerived2(A1); RESULT.setLine(A1left); :}
							| INC {: RESULT=new DesignatorStatementOptionalDerived3(); :}
							| DEC {: RESULT=new DesignatorStatementOptionalDerived4(); :};
							
ActParsOptional ::= ActPars:A1 {: RESULT=new ActParsOptionalDerived1(A1); RESULT.setLine(A1left); :}
				| {: RESULT=new ActParsOptionalDerived2(); :}
				;

DesignatorOptional ::= Designator:D1 {: RESULT=new DesignatorOptionalDerived1(D1); RESULT.setLine(D1left); :}
					| {: RESULT=new DesignatorOptionalDerived2(); :}
					;

DesignatorCommaList ::= DesignatorCommaList:D1 COMMA DesignatorOptional:D2 {: RESULT=new DesignatorCommaListDerived1(D1, D2); RESULT.setLine(D1left); :}
					| {: RESULT=new DesignatorCommaListDerived2(); :}
					;



ActPars ::= Expr:E1 ExprCommaList:E2 {: RESULT=new ActParsDerived1(E1, E2); RESULT.setLine(E1left); :};

ExprCommaList ::= ExprCommaList:E1 COMMA Expr:E2 {: RESULT=new ExprCommaListDerived1(E1, E2); RESULT.setLine(E1left); :}
				| {: RESULT=new ExprCommaListDerived2(); :}
				;

Condition ::= CondTerm:C1 CondTermList:C2 {: RESULT=new ConditionDerived1(C1, C2); RESULT.setLine(C1left); :};

CondTermList ::= CondTermList:C1 BITOR CondTerm:C2 {: RESULT=new CondTermListDerived1(C1, C2); RESULT.setLine(C1left); :}
				| {: RESULT=new CondTermListDerived2(); :}
				;

CondTerm ::= CondFact:C1 CondFactList:C2 {: RESULT=new CondTermDerived1(C1, C2); RESULT.setLine(C1left); :};

CondFactList ::= CondFactList:C1 BITAND CondFact:C2 {: RESULT=new CondFactListDerived1(C1, C2); RESULT.setLine(C1left); :}
				| {: RESULT=new CondFactListDerived2(); :}
				;
				
CondFact ::= Expr:E1 RelOpExprOptional:R2 {: RESULT=new CondFactDerived1(E1, R2); RESULT.setLine(E1left); :};

RelOpExprOptional ::= RelOp:R1 Expr:E2 {: RESULT=new RelOpExprOptionalDerived1(R1, E2); RESULT.setLine(R1left); :}
					| {: RESULT=new RelOpExprOptionalDerived2(); :}
					;



Expr ::= MinusOptional:M1 Term:T2 AddOpTermList:A3 {: RESULT=new ExprDerived1(M1, T2, A3); RESULT.setLine(M1left); :};

MinusOptional ::= MINUS {: RESULT=new MinusOptionalDerived1(); :}
			| {: RESULT=new MinusOptionalDerived2(); :}
			;

AddOpTermList ::= AddOpTermList:A1 AddOp:A2 Term:T3 {: RESULT=new AddOpTermListDerived1(A1, A2, T3); RESULT.setLine(A1left); :}
				| {: RESULT=new AddOpTermListDerived2(); :}
				;



Term ::= Factor:F1 MulOpFactorList:M2 {: RESULT=new TermDerived1(F1, M2); RESULT.setLine(F1left); :};

MulOpFactorList ::= MulOpFactorList:M1 MulOp:M2 Factor:F3 {: RESULT=new MulOpFactorListDerived1(M1, M2, F3); RESULT.setLine(M1left); :}
				| {: RESULT=new MulOpFactorListDerived2(); :}
				;



Factor ::= Designator:D1 ActParsParenOptional:A2 {: RESULT=new FactorDerived1(D1, A2); RESULT.setLine(D1left); :}
		| NUMBER:N1 {: RESULT=new FactorDerived2(N1); RESULT.setLine(N1left); :}
		| CHARCONST:C1 {: RESULT=new FactorDerived3(C1); RESULT.setLine(C1left); :}
		| BOOLCONST:B1 {: RESULT=new FactorDerived4(B1); RESULT.setLine(B1left); :}
		| NEW Type:T1 ExprOrActPars:E2 {: RESULT=new FactorDerived5(T1, E2); RESULT.setLine(T1left); :}
		| LPAREN Expr:E1 RPAREN {: RESULT=new FactorDerived6(E1); RESULT.setLine(E1left); :};




ActParsParen ::= LPAREN ActParsOptional:A1 RPAREN {: RESULT=new ActParsParenDerived1(A1); RESULT.setLine(A1left); :};

ActParsParenOptional ::= ActParsParen:A1 {: RESULT=new ActParsParenOptionalDerived1(A1); RESULT.setLine(A1left); :}
						| {: RESULT=new ActParsParenOptionalDerived2(); :}
						;

ExprOrActPars ::= LANGLE Expr:E1 RANGLE {: RESULT=new ExprOrActParsDerived1(E1); RESULT.setLine(E1left); :}
				| LPAREN ActParsOptional:A1 RPAREN {: RESULT=new ExprOrActParsDerived2(A1); RESULT.setLine(A1left); :};



Designator ::= IDENT {: RESULT=new DesignatorDerived1(); :}
			| Designator:D1 DOT IDENT {: RESULT=new DesignatorDerived2(D1); RESULT.setLine(D1left); :}
			| Designator:D1 LANGLE Expr:E2 RANGLE {: RESULT=new DesignatorDerived3(D1, E2); RESULT.setLine(D1left); :}
			;

Label ::= IDENT {: RESULT=new LabelDerived1(); :};
AssignOp ::= EQUAL {: RESULT=new AssignOpDerived1(); :};
RelOp ::= EQ {: RESULT=new RelOpDerived1(); :} | NEQ {: RESULT=new RelOpDerived2(); :} | GT {: RESULT=new RelOpDerived3(); :} | GEQ {: RESULT=new RelOpDerived4(); :} | LT {: RESULT=new RelOpDerived5(); :} | LEQ {: RESULT=new RelOpDerived6(); :};
AddOp ::= PLUS {: RESULT=new AddOpDerived1(); :} | MINUS {: RESULT=new AddOpDerived2(); :};
MulOp ::= MUL {: RESULT=new MulOpDerived1(); :} | DIV {: RESULT=new MulOpDerived2(); :} | MOD {: RESULT=new MulOpDerived3(); :};


