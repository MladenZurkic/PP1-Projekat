package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, BREAK, CLASS, ELSE, CONST, IF, WHILE, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE;
terminal FOREACH, IDENT, PLUS, MINUS, MUL, DIV, MOD, EQ, NEQ;
terminal GT, GEQ, LT, LEQ, BITAND, BITOR, EQUAL, INC, DEC, SEMI, COMMA, DOT, LPAREN, RPAREN, LANGLE;
terminal RANGLE, LBRACE, RBRACE, LAMBDAOP;
terminal  DO, ENUM, COLON;
terminal Integer NUMBER;
terminal Character CHARCONST;
terminal Boolean BOOLCONST;

nonterminal Program, DeclsList, Decls, MethodDeclList, ConstDecl, Consts, ConstsList;
nonterminal Type, VarDecl, AngleBrackets, MoreVarDecls, ClassDecl, ClassConstrMethodDecl;
nonterminal ExtendsOptional, VarDeclList, ConstMethodSecondPart, MethodRest;
nonterminal ConstructorDecl, FormParsOptional, StatementList, FormPars;
nonterminal FormParsList, MethodDecl, TypeOrVoid, Statement, DesignatorStatement;
nonterminal ElseStatementOptional, ExprOptional, NumConstOptional, DesignatorStatementOptional;
nonterminal ActParsOptional, DesignatorOptional, DesignatorCommaList, ActPars;
nonterminal ExprCommaList, Condition, CondTermList, CondTerm, CondFactList, CondFact;
nonterminal RelOpExprOptional, Expr, MinusOptional, AddOpTermList, Term, MulOpFactorList;
nonterminal Factor, ActParsParen, ActParsParenOptional, ExprOrActPars, Designator;
nonterminal Label, AssignOp, RelOp, AddOp, MulOp, ConstrMethodBothOptional, ConstsListElem;
nonterminal VarDeclErrorPossible, FormParsEnd, FormParsIdent;
nonterminal VarDeclListBasic, VarDeclComma, VarDeclEnd, VarDeclIdent;

precedence left ELSE;

Program ::= (Program) PROG IDENT:progName DeclsList LBRACE MethodDeclList RBRACE;

DeclsList ::= (Declarations) DeclsList Decls
			| 
			(NoVarDecl) /* epsilon */
			;

Decls ::= (DeclsConstDecl) ConstDecl
		| (DeclsVarDecl) VarDeclErrorPossible
		| (DeclsClassDecl) ClassDecl;


MethodDeclList ::= MethodDeclList MethodDecl  
				| (NoMethodDeclList) /* epsilon */
				;

ConstDecl ::= (ConstDeclDef) CONST Type:type ConstsList SEMI;
			

Consts ::= (ConstsNumber) NUMBER
		| (ConstsCharConst) CHARCONST
		| (ConstsBoolConst) BOOLCONST;
		
ConstsList ::= (ConstsListDef) ConstsList COMMA ConstsListElem
			| (ConstsListElemInList) ConstsListElem
			;
			
ConstsListElem ::= (ConstsListElem) IDENT:id EQUAL Consts:value;

Type ::= (Type) IDENT:typeName;

VarDecl ::= (DefVarDecl) Type:typeName VarDeclIdent MoreVarDecls SEMI;

VarDeclErrorPossible ::= (VarDeclErrorPossible) Type:typeName VarDeclListBasic;

VarDeclListBasic ::= (VarDeclListBasicDef) VarDeclComma VarDeclListBasic
				| (VarDeclListBasicEnd) VarDeclEnd;


VarDeclComma ::= (VarDeclCommaDef) VarDeclIdent COMMA
				| (ErrorVarDeclListBasic) error:err COMMA
				{: parser.report_error("Izvrsen oporavak do , (VarDeclComma) u liniji " + errleft, null);  :}
				;

VarDeclEnd ::= (VarDeclEndDef) VarDeclIdent SEMI
			| (ErrorVarDecl) error:err SEMI
			{: parser.report_error("Izvrsen oporavak do ; (VarDeclEnd) u liniji " + errleft, null);  :}
			;

VarDeclIdent ::= (VarDeclIdent) IDENT:ident AngleBrackets;


AngleBrackets ::= (AngleBrackets) LANGLE RANGLE
				| (NoAngleBrackets) /* epsilon */
				;

MoreVarDecls ::= (MoreVarDeclsDef) MoreVarDecls COMMA VarDeclIdent
			| (MoreVarDeclsEpislon) /* epsilon */
			;
			
ClassDecl ::= (ClassDecl) CLASS IDENT:ident ExtendsOptional LBRACE VarDeclList ClassConstrMethodDecl RBRACE;

ExtendsOptional ::= (ExtendsOptionalDef) EXTENDS Type:typeName
			| (ExtendsOptionalEpsilon) /* epsilon */
			;

VarDeclList ::= (VarDeclsList) VarDeclList VarDecl
			| (VarDeclsListEpsilon) /* epsilon */
			;
			
ClassConstrMethodDecl ::= (ClassConstrMethodDeclDef) LBRACE ConstrMethodBothOptional RBRACE
						| (ClassConstrMethodDeclEpsilon) /* epsilon */
						;

ConstrMethodBothOptional ::= (ConstrMethodBothConstrPart) IDENT:ident ConstMethodSecondPart ConstrMethodBothOptional
							| (ConstrMethodBothMethodIdentPart) IDENT:typeName IDENT:ident ConstMethodSecondPart MethodRest
							| (ConstrMethodBothMethodVoidPart) VOID:typeName IDENT:ident ConstMethodSecondPart MethodRest
							| (ConstrMethodBothMethodEpsilon) /* epsilon */
							;

ConstMethodSecondPart ::= (ConstMethodSecondPart) LPAREN FormParsOptional VarDeclList LBRACE StatementList RBRACE;

MethodRest ::= (MethodRestIdent) IDENT:typeName IDENT:ident ConstMethodSecondPart MethodRest
			| (MethodRestVoid) VOID:typeName IDENT:ident ConstMethodSecondPart MethodRest
			| (MethodRestEpsilon) /* epsilon */
			;

ConstructorDecl ::= (ConstructorDecl) IDENT:ident LPAREN FormParsOptional VarDeclList LBRACE StatementList RBRACE;

FormParsOptional ::= (FormParsOptionalPars) FormPars
					| (FormParsOptionalRPAREN) RPAREN
					;
					
StatementList ::= (StatementListDef) StatementList Statement
				| (StatementListEpsilon) /* epsilon */
				;

FormPars ::= (FormParsWithList) FormParsList FormPars
			| (FormParsListEnd) FormParsEnd
			;

FormParsList ::= (FormParsListWithCOMMA) FormParsIdent COMMA
				| (ErrorFormParsListCOMMA) error:err COMMA
				{: parser.report_error("Izvrsen oporavak do , (FormParsList) u liniji " + errleft, null);  :}
				;
				
FormParsEnd ::= (FormParsEndWithRPAREN) FormParsIdent RPAREN
			| (ErrorFormParsEndRPAREN) error:err RPAREN
			{: parser.report_error("Izvrsen oporavak do ) (FormParsEnd) u liniji " + errleft, null);  :}
			;
			
FormParsIdent ::= (FormParsIdent) Type:typeName IDENT:formName AngleBrackets;
				
MethodDecl ::= (MethodDecl) TypeOrVoid:typeName IDENT:methName LPAREN FormParsOptional VarDeclList LBRACE StatementList RBRACE;

TypeOrVoid ::= (TypeOrVoidType) Type:typeName
			| (TypeOrVoidVoid) VOID:typeName;

Statement ::= (DesignatorStmt) DesignatorStatement:designatorStmt
			| (IfStmt) IF LPAREN Condition:condition RPAREN Statement:stmt ElseStatementOptional
			| (WhileStmt) WHILE LPAREN Condition:condition RPAREN Statement:stmt
			| (BreakStmt) BREAK SEMI
			| (ContinueStmt) CONTINUE SEMI
			| (ReturnStmt) RETURN ExprOptional:ExprOpt SEMI
			| (ReadStmt) READ LPAREN Designator:designator RPAREN SEMI
			| (PrintStmt) PRINT LPAREN Expr:expr NumConstOptional:numOpt RPAREN SEMI
			| (ForEachStmt) Designator:designator DOT FOREACH LPAREN IDENT:ident LAMBDAOP Statement:stmt RPAREN SEMI
			| (StmtList) LBRACE StatementList RBRACE
			| (ErrorStmtIFCondition) IF LPAREN error:err RPAREN
			{: parser.report_error("Izvrsen oporavak do ) (IF condition) u liniji " + errleft, null);  :}
			;

DesignatorStatement ::= (DesignatorStmtDef) Designator DesignatorStatementOptional SEMI
					| (DesignatorStmtAngleBrack) LANGLE DesignatorOptional DesignatorCommaList RANGLE EQUAL Designator SEMI
					| (ErrorDesignatorStmtSEMI) error:err SEMI
					{: parser.report_error("Izvrsen oporavak do ; (DesignatorStmt) u liniji " + errleft, null);  :}
					;

ElseStatementOptional ::= (ElseStmtOpt) ELSE Statement:stmt
						| (ElseStmtEpsilon) /* epsilon */
						;

ExprOptional ::= (ExprOpt) Expr:expr
				| (ExprEpsilon) /* epsilon */
				;

NumConstOptional ::= (NumConstOpt) COMMA NUMBER
				| (NumConstEpsilon) /* epsilon */
				;




DesignatorStatementOptional ::= (DesignatorStmtOptAssign) AssignOp Expr:expr
							| (DesignatorStmtOptActPars) LPAREN ActParsOptional RPAREN
							| (DesignatorStmtOptINC) INC
							| (DesignatorStmtOptDEC) DEC;
							
ActParsOptional ::= (ActParsOpt) ActPars
				| (ActParsOptEpsilon) /* epsilon */
				;

DesignatorOptional ::= (DesignatorOpt) Designator
					| (DesignatorOptEpsilon) /* epsilon */
					;

DesignatorCommaList ::= (DesignatorCommaListDef) DesignatorCommaList COMMA DesignatorOptional
					| (DesignatorCommaListEpsilon) /* epsilon */
					;



ActPars ::= (ActPars) Expr:expr ExprCommaList;

ExprCommaList ::= (ExprCommaListDef) ExprCommaList COMMA Expr:expr
				| (ExprCommaListEpsilon) /* epsilon */
				;

Condition ::= (Condition) CondTerm CondTermList;

CondTermList ::= (CondTermListDef) CondTermList BITOR CondTerm
				| (CondTermListEpsilon) /* epsilon */
				;

CondTerm ::= (CondTerm) CondFact CondFactList;

CondFactList ::= (CondFactListDef) CondFactList BITAND CondFact
				| (CondFactListEpsilon) /* epsilon */
				;
				
CondFact ::= (CondFact) Expr RelOpExprOptional;

RelOpExprOptional ::= (RelOpExprDef) RelOp Expr
					| (RelOpExprEpsilon) /* epsilon */
					;



Expr ::= (Expr) MinusOptional Term:term AddOpTermList;

MinusOptional ::= (MinusDef) MINUS
			| (MinusEpsilon) /* epsilon */
			;

AddOpTermList ::= (AddOpTermListDef) AddOpTermList AddOp Term:term
				| (AddOpTermListEpsilon) /* epsilon */
				;



Term ::= (Term) Factor:factor MulOpFactorList;

MulOpFactorList ::= (MulOpFactorListDef) MulOpFactorList MulOp Factor
				| (MulOpFactorListEpsilon) /* epsilon */
				;



Factor ::= (FactorDesignator) Designator:designator ActParsParenOptional
		| (FactorNumber) NUMBER
		| (FactorChar) CHARCONST
		| (FactorBool) BOOLCONST
		| (FactorNew) NEW Type:typeName ExprOrActPars
		| (FactorExpr) LPAREN Expr:expr RPAREN;




ActParsParen ::= (ActParsParen) LPAREN ActParsOptional RPAREN;

ActParsParenOptional ::= (ActParsParenDef) ActParsParen
						| (ActParsParenEpsilon) /* epsilon */
						;

ExprOrActPars ::= (ExprOrActParsExpr) LANGLE Expr:expr RANGLE
				| (ExprOrActParsActPars) LPAREN ActParsOptional RPAREN;



Designator ::= (DesignatorIdent) IDENT:ident
			| (DesignatorDotIdent) Designator:designator DOT IDENT:ident
			| (DesignatorExpr) Designator:designator LANGLE Expr RANGLE
			;

Label ::= (Label) IDENT:ident;
AssignOp ::= (AssignOp) EQUAL;
RelOp ::= (RelEQ) EQ | (RelNEQ) NEQ | (RelGT) GT | (RelGEQ) GEQ | (RelLT) LT | (RelLEQ) LEQ;
AddOp ::= (AddPLUS) PLUS | (AddMINUS) MINUS;
MulOp ::= (MulMUL) MUL | (MulDIV) DIV | (MulMOD) MOD;


